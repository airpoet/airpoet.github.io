<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习笔记-5]]></title>
    <url>%2F2018%2F05%2F28%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%2F</url>
    <content type="text"><![CDATA[1.Shell操作日期时间date在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。 语法 1date(选项)(参数) 选项 12345-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT, 即目前的格林威治时间；--help：在线帮助；--version：显示版本信息。 参数 &lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。 日期格式字符串列表 123456789101112131415161718192021222324%r 时间，12小时制%s 从1970年1月1日0点到目前经历的秒数%S 秒（00～59） %T 时间（24小时制）（hh:mm:ss）%X 显示时间的格式（％H时％M分％S秒）%Z 按字母表排序的时区缩写%a 星期名缩写%A 星期名全称%b 月名缩写%B 月名全称%c 日期和时间%d 按月计的日期（01～31）%D 日期（mm/dd/yy） %h 和%b选项相同%j 一年的第几天（001~366）%m 月份（01～12）%w 一个星期的第几天（0代表星期天）%W 一年的第几个星期（00～53，星期一为第一天）%x 显示日期的格式（mm/dd/yy）%y 年份的最后两个数字（1999则是99）%Y 年份（比如1970、1996等）%C 世纪，通常为省略当前年份的后两位数字%U 一年中的第几周，以周日为每星期第一天%e 按月计的日期，添加空格，等于%_d 实例 格式化输出 12date +"%Y-%m-%d"2009-12-07 输出昨天日期： 12date -d "1 day ago" +"%Y-%m-%d"2012-11-19 2秒后输出： 12date -d "2 second" +"%Y-%m-%d %H:%M.%S"2012-11-20 14:21.31 传说中的 1234567890 秒： 12date -d "1970-01-01 1234567890 seconds" +"%Y-%m-%d %H:%m:%S"2009-02-13 23:02:30 普通转格式： 12date -d "2009-12-12" +"%Y/%m/%d %H:%M.%S"2009/12/12 00:00.00 apache格式转换： 12date -d "Dec 5, 2009 12:00:37 AM" +"%Y-%m-%d %H:%M.%S"2009-12-05 00:00.37 格式转换后时间游走： 12date -d "Dec 5, 2009 12:00:37 AM 2 year ago" +"%Y-%m-%d %H:%M.%S"2007-12-05 00:00.37 加减操作： 1234567date +%Y%m%d //显示前天年月日date -d "+1 day" +%Y%m%d //显示前一天的日期date -d "-1 day" +%Y%m%d //显示后一天的日期date -d "-1 month" +%Y%m%d //显示上一月的日期date -d "+1 month" +%Y%m%d //显示下一月的日期date -d "-1 year" +%Y%m%d //显示前一年的日期date -d "+1 year" +%Y%m%d //显示下一年的日期 设定时间： 1234567date -s //设置当前时间，只有root权限才能设置，其他只能查看date -s 20120523 //设置成20120523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s "01:01:01 2012-05-23" //这样可以设置全部时间date -s "01:01:01 20120523" //这样可以设置全部时间date -s "2012-05-23 01:01:01" //这样可以设置全部时间date -s "20120523 01:01:01" //这样可以设置全部时间 有时需要检查一组命令花费的时间，举例： 12345678#!/bin/bashstart=$(date +%s)nmap man.linuxde.net &amp;&gt; /dev/nullend=$(date +%s)difference=$(( end - start ))echo $difference seconds. 计算活了多少年 1echo $[($(date +%s -d $[date])-$(date +%s -d "19900318"))/86400/365] date -d其它的一些用法. 123456789101112131415161718192021222324252627## 获取下一天的时间[root@hadoop ~]# date -d next-day '+%Y-%m-%d %H:%M:%S'[root@hadoop ~]# date -d 'next day' '+%Y-%m-%d %H:%M:%S'另外一种写法：[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' -d tomorrow## 获取上一天的时间 [root@hadoop ~]# date -d last-day '+%Y-%m-%d %H:%M:%S'另外一种写法：[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' -d yesterday## 获取下一月的时间[root@hadoop ~]# date -d next-month '+%Y-%m-%d %H:%M:%S'## 获取上一月的时间 [root@hadoop ~]# date -d last-month '+%Y-%m-%d %H:%M:%S'## 获取下一年的时间[root@hadoop ~]# date -d next-year '+%Y-%m-%d %H:%M:%S'## 获取上一年的时间 [root@hadoop ~]# date -d last-year '+%Y-%m-%d %H:%M:%S'## 获取上一周的日期时间：[root@hadoop ~]# date -d next-week '+%Y-%m-%d %H:%M:%S'[root@hadoop ~]# date -d next-monday '+%Y-%m-%d %H:%M:%S'[root@hadoop ~]# date -d next-thursday '+%Y-%m-%d %H:%M:%S' 那么类似的，其实，last-year，last-month，last-day，last-week，last-hour，last-minute，last-second都有对应的实现。相反的，last对应next，自己可以根据实际情况灵活组织 接下来，我们来看‘–date’，它帮我实现任意时间前后的计算，来看具体的例子： 1234567## 获取一天以后的日期时间[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' --date='1 day'[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' --date='-1 day ago'## 获取一天以前的日期时间[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' --date='-1 day'[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' --date='1 day ago' 上面的例子显示出来了使用的格式，使用精髓在于改变前面的字符串显示格式，改变数据，改变要操作的日期对应字段，除了天也有对应的其他实现：year，month，week，day，hour，minute，second，monday（星期，七天都可） date 能用来显示或设定系统的日期和时间，在显示方面，使用者能设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 使用范例： 1[root@hadoop ~]# date '+%Y-%m-%d %H:%M:%S' 日期方面 12345678910111213141516%a : 星期几 (Sun..Sat) %A : 星期几 (Sunday..Saturday) %b : 月份 (Jan..Dec) %B : 月份 (January..December) %c : 直接显示日期和时间 %d : 日 (01..31) %D : 直接显示日期 (mm/dd/yy) %h : 同 %b %j : 一年中的第几天 (001..366) %m : 月份 (01..12) %U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形) %w : 一周中的第几天 (0..6) %W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形) %x : 直接显示日期 (mm/dd/yyyy) %y : 年份的最后两位数字 (00.99) %Y : 完整年份 (0000..9999) 时间方面 123456789101112131415%%: 打印出%%n : 下一行%t : 跳格%H : 小时(00..23)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地AM或PM%P : 显示本地am或pm%r : 直接显示时间(12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间(24小时制)%X : 相当于%H:%M:%S %p%Z : 显示时区 若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss] 1234567MM 为月份， DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数 有用的小技巧12345678910111213141516171819202122## 获取相对某个日期前后的日期：cts1 ~ # date -d 'may 14 -2 weeks'2018年 04月 30日 星期一 00:00:00 CST## 把时间当中无用的0去掉，比如：01:02:25会变成1:2:25cts1 ~ # date '+%-H:%-M:%-S'19:18:22## 显示文件最后被更改的时间cts1 ~ # date "+%Y-%m-%d %H:%M:%S" -r install.log2018-05-23 10:11:14## 求两个字符串日期之间相隔的天数[root@hadoop ~]# expr '(' $(date +%s -d "2016-08-08") - $(date +%s -d "2016-09-09") ')' / 86400expr `expr $(date +%s -d "2016-08-08") - $(date +%s -d "2016-09-09")` / 86400## shell中加减指定间隔单位cts1 ~ # A=`date +%Y-%m-%d`cts1 ~ # B=`date +%Y-%m-%d -d "$A +48 hours"`cts1 ~ # echo $B2018-05-30 2. 文本处理wc功能： 统计文件行数、字节、字符数 选项1234567-c # 统计字节数，或--bytes或——chars：只显示Bytes数；。-l # 统计行数，或——lines：只显示列数；。-m # 统计字符数。这个标志不能与 -c 标志一起使用。-w # 统计字数，或——words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。-L # 打印最长行的长度。-help # 显示帮助信息--version # 显示版本信息 例子123456789101112131415161718192021222324wc -l * # 统计当前目录下的所有文件行数wc -l *.js # 统计当前目录下的所有 .js 后缀的文件行数find . * | xargs wc -l # 当前目录以及子目录的所有文件行数 wc test.txt # 查看文件的字节数、字数、行数# 查看文件的字节数、字数、行数wc test.txt# 输出结果7 8 70 test.txt行数 单词数 字节数 文件名# 用wc命令只打印统计文件行数不打印文件名wc -l test.txt # 输出结果7 test.txt# 用来统计当前目录下的文件数ls -l | wc -l# 输出结果8# 统计文件字数：cts1 ~ # wc -w date.txt30 date.txt sortsort命令 是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。 选项123456789101112131415-b：忽略每行前面开始出的空格字符；-c：检查文件是否已经按照顺序排序；-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；-f：排序时，将小写字母视为大写字母；-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；-m：将几个排序号的文件进行合并；-M：将前面3个字母依照月份的缩写进行排序；-n：依照数值的大小排序；-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；-r：以相反的顺序来排序；-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；-g：按照常规数值排序-k：位置1,位置2根据关键字排序，在从第位置1开始，位置2结束+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 实例 sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 123456789101112131415root@[mail text]# cat sort.txtaaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5eee:50:5.5[root@mail text]# sort sort.txtaaa:10:1.1bbb:20:2.2ccc:30:3.3ddd:40:4.4eee:50:5.5eee:50:5.5 忽略相同行使用-u选项或者uniq： 1234567891011121314151617181920212223[root@mail text]# cat sort.txtaaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5eee:50:5.5[root@mail text]# sort -u sort.txtaaa:10:1.1bbb:20:2.2ccc:30:3.3ddd:40:4.4eee:50:5.5或者[root@mail text]# uniq sort.txtaaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5 sort的-n、-r、-k、-t选项的使用： 123456789101112131415161718192021222324252627282930313233[root@mail text]# cat sort.txtAAA:BB:CCaaa:30:1.6ccc:50:3.3ddd:20:4.2bbb:10:2.5eee:40:5.4eee:60:5.1#将BB列按照数字从小到大顺序排列：[root@mail text]# sort -nk 2 -t: sort.txtAAA:BB:CCbbb:10:2.5ddd:20:4.2aaa:30:1.6eee:40:5.4ccc:50:3.3eee:60:5.1#将CC列数字从大到小顺序排列：[root@mail text]# sort -nrk 3 -t: sort.txteee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC# -n是按照数字大小排序，-r是以相反顺序，-k是指定需要排序的栏位，-t指定栏位分隔符为冒号# 多列排序：以:分隔，按第二列数值排倒序，第三列正序[linux@linux ~]$ sort -n -t: -k2,2r -k3 sort.txt -k选项的具体语法格式： x,x 表示一个范围 123FStart.CStart Modifie,FEnd.CEnd Modifier-------Start--------,-------End-------- FStart.CStart 选项 , FEnd.CEnd 选项 这个语法格式可以被其中的逗号,分为两大部分， Start 部分和 End 部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。我们重点说说Start部分的FStart和C.Start。C.Start也是可以省略的，省略的话就表示从本域的开头部分开始。FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。 从公司英文名称的第二个字母开始进行排序： 1234567# 先创建此txt文件# 再排序$ sort -t ' ' -k 1.2 facebook.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000 -t &#39; &#39;, 首先用&#39; &#39;空格, 把字段分割成了3个域. 使用了-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。你会发现baidu因为第二个字母是a而名列榜首。sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三。guge只能屈居第四了。 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序： 12345$ sort -t ' ' -k 1.2,1.2 -nrk 3,3 facebook.txtbaidu 100 5000google 110 5000sohu 100 4500guge 50 3000 由于只对第二个字母进行排序，所以我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。对于员工工资进行排 序，我们也使用了-k 3,3，这是最准确的表述，表示我们“只”对本域进行排序，因为如果你省略了后面的3，就变成了我们“对第3个域开始到最后一个域位置的内容进行排序” 了。 uniquniq命令 用于报告或忽略文件中的重复行，一般与sort命令结合使用。 选项123456-c或——count：在每列旁边显示该行重复出现的次数；-d或--repeated：仅显示重复出现的行列；-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；-u或——unique：仅显示出一次的行列；-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。 参数 输入文件：指定要去除的重复行文件。如果不指定此项，则从标准读取数据； 输出文件：指定要去除重复行后的内容要写入的输出文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root]# cat sort.txt : 原本行aaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5eee:50:5.5[root]# uniq sort.txt : 不展示重复行aaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5[cts1:Desktop][cts1:Desktop][root]# sort sort.txt | uniq : 不展示重复行aaa:10:1.1bbb:20:2.2ccc:30:3.3ddd:40:4.4eee:50:5.5[cts1:Desktop][root]# uniq -u sort.txt : 删除重复行aaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2[cts1:Desktop][root]# sort sort.txt | uniq -u : 排序并删除重复行aaa:10:1.1bbb:20:2.2ccc:30:3.3ddd:40:4.4[cts1:Desktop][root]# sort sort.txt | uniq -c : 展示每行出现的次数 1 aaa:10:1.1 1 bbb:20:2.2 1 ccc:30:3.3 1 ddd:40:4.4 2 eee:50:5.5[cts1:Desktop][root]# sort sort.txt | uniq -d : 只展示重复行eee:50:5.5# 求a.txt和b.txt的差集 ## 首先a b 去掉重复的, 再跟a b去重, 把b其它的部分也去掉cts1 Desktop # cat a b b | sort | uniq -uab# 求b.txt和a.txt的差集 ## 同上cts1 Desktop # cat b a a | sort | uniq -uef cutcut命令 用来显示行中的指定部分，删除文件中指定字段。cut经常用来显示文件的内容，类似于下的type命令。 说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数file所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如cut fl f2 &gt; f3将把文件fl和几的内容合并起来，然后通过输出重定向符“&gt;”的作用，将它们放入文件f3中。 当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。 选项123456789-b：仅显示行中指定直接范围的内容；-c：仅显示行中指定范围的字符； -d：指定字段的分隔符，默认的字段分隔符为“TAB”； -f：显示指定字段的内容；-n：与“-b”选项连用，不分割多字节字符；--complement：补足被选择的字节、字符或字段；--out-delimiter=&lt;字段分隔符&gt;：指定输出内容是的字段分割符；--help：显示指令的帮助信息；--version：显示指令的版本信息。 参数文件：指定要进行内容过滤的文件。 实例例如有一个学生报表信息，包含No、Name、Mark、Percent： 12345[root@localhost text]# cat cut.txt No Name Mark Percent01 tom 69 9102 jack 71 8703 alex 68 98 -f使用-f 选项提取指定字段 12345[root@localhost text]# cut -d ' ' -f1 cut.txt No010203 12345[root@localhost text]# cut -d ' ' -f2,3 test.txt Name Marktom 69jack 71alex 68 –complement选项提取指定字段之外的列（打印除了第二列之外的列）： 12345cut -d ' ' -f2 --complement cut.txtNo Mark Percent01 69 9102 71 8703 68 98 指定字段的字符或者字节范围 &amp; 例子cut命令可以将一串字符作为列来显示，字符字段的记法： N- ：从第N个字节、字符、字段到结尾； N-M ：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段； -M ：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。 上面是记法，结合下面选项将摸个范围的字节、字符指定为字段： -b 表示字节； -c 表示字符； -f 表示定义字段。 实例123456789101112131415161718192021222324252627282930[root@localhost text]# cat test.txt abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz# 打印第1个到第3个字符：cut -c1-3 test.txt abcabcabcabcabc# 打印前2个字符：cut -c-2 test.txt ababababab# 打印从第5个字符开始到结尾：cut -c5- test.txt efghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyz grep(文本生成器)grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。 选项123456789101112131415161718192021222324252627-a --text # 不要忽略二进制数据。-A &lt;显示行数&gt; --after-context=&lt;显示行数&gt; # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b --byte-offset # 在显示符合范本样式的那一行之外，并显示该行之前的内容。-B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; # 除了显示符合样式的那一行之外，并显示该行之前的内容。-c --count # 计算符合范本样式的列数。-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; --directories=&lt;动作&gt; # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; # 指定字符串作为查找文件内容的范本样式。-E --extended-regexp # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; --file=&lt;规则文件&gt; # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F --fixed-regexp # 将范本样式视为固定字符串的列表。-G --basic-regexp # 将范本样式视为普通的表示法来使用。-h --no-filename # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H --with-filename # 在显示符合范本样式的那一列之前，标示该列的文件名称。-i --ignore-case # 忽略字符大小写的差别。-l --file-with-matches # 列出文件内容符合指定的范本样式的文件名称。-L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。-n --line-number # 在显示符合范本样式的那一列之前，标示出该列的编号。-q --quiet或--silent # 不显示任何信息。-R/-r --recursive # 此参数的效果和指定“-d recurse”参数相同。-s --no-messages # 不显示错误信息。-v --revert-match # 反转查找。-V --version # 显示版本信息。 -w --word-regexp # 只显示全字符合的列。-x --line-regexp # 只显示全列符合的列。-y # 此参数效果跟“-i”相同。-o # 只输出文件中匹配到的部分。 grep中的正则表达式12345678910111213141516171819202122232425^ # 锚定行的开始 如：'^grep'匹配所有以grep开头的行。 $ # 锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 . # 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。 * # 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。 .* # 一起用代表任意字符。 [] # 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 [^] # 匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \ # 转义\(..\) # 标记匹配字符，如'\(love\)'，love被标记为1。 \&lt; # 锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。 \&gt; # 锚定单词的结束，如'grep\&gt;'匹配包含以grep结尾的单词的行。 x\&#123;m\&#125; # 重复字符x，m次，如：'o\&#123;5\&#125;'匹配包含5个o的行。 x\&#123;m,\&#125; # 重复字符x,至少m次，如：'o\&#123;5,\&#125;'匹配至少有5个o的行。 x\&#123;m,n\&#125; # 重复字符x，至少m次，不多于n次，如：'o\&#123;5,10\&#125;'匹配5--10个o的行。 \w # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。 \W # \w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \b # 单词锁定符，如: '\bgrep\b'只匹配grep。增录. # 任意一个字符a* # 任意多个a(0个或多个)a? # 0个或1个aa+ # 一个或多个a[A-Z][ABC] grep命令常见用法 在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行： 12grep match_pattern file_namegrep "match_pattern" file_name 在多个文件中查找 1grep "match_pattern" file_1 file_2 file_3 ... 输出除 “match_pattern” 之外的所有行 &gt;&gt; -v 选项： 1grep -v "match_pattern" file_name 标记匹配颜色 –color=auto 选项： 12345678910grep "match_pattern" file_name --color=autoeg: 查找当前目录下所有文件中的 `a`cts1 Desktop # grep "\(a\)" ./* --color=auto---./a:a./abc.txt:abcdefghijklmnopqrstuvwxyz./abc.txt:abcdefghijklmnopqrstuvwxyz./abc.txt:abcdefghijklmnopqrstuvwxyz... 使用正则表达式 -E 选项：123grep -E "[1-9]+"或egrep "[1-9]+" 只输出文件中匹配到的部分 -o 选项： 12345echo this is a test line. | grep -o -E "[a-z]+\."line.echo this is a test line. | egrep -o "[a-z]+\."line. 统计文件或者文本中包含匹配字符串的行数 -c 选项： 1grep -c "text" file_name 输出包含匹配字符串的行数 -n 选项： 123456grep "text" -n file_name或cat file_name | grep "text" -n#多个文件grep "text" -n file_1 file_2 打印样式匹配所位于的字符或字节偏移 1234echo gun is not unix | grep -b -o "not"7:not#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 **-b -o** 一般总是配合使用。 搜索多个文件并查找匹配文本在哪些文件中 1grep -l "text" file1 file2 file3... grep递归搜索文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 在多级目录中对文本进行递归搜索grep "text" . -r -n# .表示当前目录。# 忽略匹配样式中的字符大小写echo "hello world" | grep -i "HELLO"hello# 选项 -e 制动多个匹配样式：echo this is a text line | grep -e "is" -e "line" -oisline#也可以使用 **-f** 选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。cat patfileaaabbb# 用文件名称匹配, 实际上就是匹配文件中的内容echo aaa bbb ccc ddd eee | grep -f patfile -oaaabbb# 在grep搜索结果中包括或者排除指定文件：---#只在目录中所有的.php和.html文件中递归搜索字符"main()"grep "main()" . -r --include *.&#123;php,html&#125;#在搜索结果中排除所有README文件grep "main()" . -r --exclude "README"#在搜索结果中排除filelist文件列表里的文件grep "main()" . -r --exclude-from filelist---# 使用0值字节后缀的grep与xargs：---# 测试文件：echo "aaa" &gt; file1echo "bbb" &gt; file2echo "aaa" &gt; file3grep "aaa" file* -lZ | xargs -0 rm#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。# 好吧, 暂时我也没懂是啥意思...---# grep静默输出：grep -q "test" filename# 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。# 打印出匹配文本之前或者之后的行：# 显示匹配某个结果之后的3行，使用 -A 选项：seq 10 | grep "5" -A 35678# 显示匹配某个结果之前的3行，使用 -B 选项：seq 10 | grep "5" -B 32345# 显示匹配某个结果的前三行和后三行，使用 -C 选项：seq 10 | grep "5" -C 32345678# 如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：echo -e "a\nb\nc\na\nb\nc" | grep a -A 1ab--ab grep其它常用用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 统计出现某个字符串的行的总行数 '-c'cts1 Desktop # echo "hello" &gt;&gt; hello.shcts1 Desktop # grep -c 'hello' hello.sh1# 查询不包含hello的行, 带有hello的整行都不会被查询到 '-v'cts1 Desktop # grep -v 'hello' hello.sh....# `.*`的用法, 前后都是 `.*` , 只要包含 parrten 的 整行 都会被查出来grep '.*hello.*' hello.sh# 任何由 'h..p'包含的都会被查出来. 查的当前行, .* 代表任意字符cts1 Desktop # grep 'h.*p' /etc/passwdgopher:x:13:30:gopher:/var/gopher:/sbin/nologinrpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nolo# 正则表达以 ro 开头cts1 Desktop # grep '^ro' /etc/passwdroot:x:0:0:root:/root:/bin/zsh# 正则表达以 t 结尾cts1 Desktop # grep 't$' /etc/passwdhalt:x:7:0:halt:/sbin:/sbin/halt# '[Gg]rep'匹配Grep和grep## 此处是匹配 以 h || r 开头的cts1 Desktop # grep '^[hr]' /etc/passwdroot:x:0:0:root:/root:/bin/zshhalt:x:7:0:halt:/sbin:/sbin/haltrpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nologin# 匹配非h之外其他的, 和 r 开头的, 也就是匹配 h以外的cts1 Desktop # grep '^[hr]' /etc/passwdroot:x:0:0:root:/root:/bin/zshhalt:x:7:0:halt:/sbin:/sbin/haltrpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nologin# 匹配 h-r 以外的cts1 Desktop # grep '^[^h-r]' /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin... sed(流编辑器)sed叫做流编辑器，在shell脚本和Makefile中作为过滤一使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一系列编辑命令转换成为另一种格式输出。sed是一种在线编辑器，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为”模式空间”,接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 选项12345678910111213-n：一般sed命令会把所有数据都输出到屏幕，如果加入-n选项的话，则只会把经过sed命令处理的行输出到屏幕。-e&lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件； 允许对输入数据应用多条sed命令编辑。-i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。-f&lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；-n或--quiet或——silent：仅显示script处理后的结果；--version：显示版本信息。# 动作:a：追加，在当前行后添加一行或多行。c：行替换，用c后面的字符串替换原数据行。i：插入，在当前行前插入一行或多行。p：打印，输出指定的行。s：字符串替换，用一个字符串替换另外一个字符串。格式为**\'**行范围s/旧字符串/新字符串/g**\'** (如果不加g的话，则表示只替换每行第一个匹配的串) sed元字符集(正则)12345678910111213**^** 匹配行开始，如：/^sed/匹配所有以sed开头的行。**$** 匹配行结束，如：/sed$/匹配所有以sed结尾的行。**.** 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。**** * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。**[]** 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 **[^]** 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。**\(..\)** 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。**&amp;** 保存搜索字符用来替换其他字符，如s/love/ **&amp;** /，love这成 **love** 。**\&lt;** 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。**\&gt;** 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。**x\&#123;m\&#125;** 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。**x\&#123;m,\&#125;** 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。**x\&#123;m,n\&#125;** 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。 实例 删除: d命令 sed ‘2d’ sed.txt —–删除sed.txt文件的第二行。 sed ‘2,$d’ sed.txt —–删除sed.txt文件的第二行到末尾所有行。 sed ‘$d’ sed.txt —–删除sed.txt文件的最后一行。 sed ‘/test/d ‘ sed.txt —–删除sed.txt文件所有包含test的行。 sed ‘/[A-Za-z]/d ‘ sed.txt —–删除sed.txt文件所有包含字母的行。 整行替换: c命令 将第二行替换成hello world sed \’2c hello world\’ sed.txt 字符串替换：s命令 sed ‘s/hello/hi/g’ sed.txt ## 在整行范围内把hello替换为hi。如果没有g标记，则只有每行第一个匹配的hello被替换成hi。 sed ‘s/hello/hi/2’ sed.txt ## 此种写法表示只替换每行的第2个hello为hi sed ‘s/hello/hi/2g’ sed.txt ## 此种写法表示只替换每行的第2个以后的hello为hi（包括第2个） sed -n ‘s/^hello/hi/p’ sed.txt ## (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的hello被替换成hi，就打印它。 sed -n ‘2,4p’ sed.txt ## 打印输出sed.txt中的第2行和第4行 sed -n ‘s/hello/&amp;-hi/gp’ sed.txt sed ‘s/^192.168.0.1/&amp;-localhost/‘ sed.txt sed ‘s/^192.168.0.1/[&amp;]/‘ sed.txt ## &amp;符号表示追加一个串到找到的串后, &amp;代表前一个串。 所有以192.168.0.1开头的行都会被替换成它自已加 -localhost，变成192.168.0.1-localhost。 第三句表示给IP地址添加中括号 sed -n ‘s/(liu)jialing/\1tao/p’ sed.txt sed -n ‘s/(liu)jia(ling)/\1tao\2ss/p’ sed.txt ## liu被标记为\1，所以liu会被保留下来（\1 == liu） ## ling被标记为\2，所以ling也会被保留下来（\2 == ling） ## 所以最后的结果就是\1tao\2ss == “liu” + “tao” + “ling” + “ss” 此处切记：\1代表的是被第一个()包含的内容，\1代表的是被第一个()包含的内容，…… 上面命令的意思就是：被括号包含的字符串会保留下来，然后跟其他的字符串比如tao和ss组成新的字符串liutaolingss sed ‘s#hello#hi#g’ sed.txt ## 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，”#”在这里是分隔符，代替了默认的”/“分隔符。表示把所有hello替换成hi。 选定行的范围：逗号 sed -n ‘/today/,/hello/p’ sed.txt ## 所有在模板today和hello所确定的范围内的行都被打印。都找第一个，也就是说，从第一个today到第一个hello sed -n ‘5,/^hello/p’ sed.txt sed -n ‘/^hello/,8p’ sed.txt ## 打印从第五行开始到第一个包含以hello开始的行之间的所有行。 sed ‘/today/,/hello/s/$/www/‘ sed.txt ## 对于模板today和hello之间的行，每行的末尾用字符串www替换。 sed ‘/today/,/hello/s/^/www/‘ sed.txt ## 对于模板today和hello之间的行，每行的开头用字符串www替换。 sed ‘/^[A-Za-z]/s/5/five/g’ sed.txt ## 将以字母开头的行中的数字5替换成five 多点编辑：e命令 sed -e ‘1,5d’ -e ‘s/hello/hi/‘ sed.txt ## (-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用hello替换hi。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。 sed –expression=’s/hello/hi/‘ –expression=’/today/d’ sed.txt ## 一个比-e更好的命令是–expression。它能给sed表达式赋值。 从文件读入：r命令 sed ‘/hello/r file’ sed.txt ## file里的内容被读进来，显示在与hello匹配的行下面，如果匹配多行，则file的内容将显示在所有匹配行的下面。 写入文件：w命令 sed -n ‘/hello/w file’ sed.txt ## 在huangbo.txt中所有包含hello的行都被写入file里。 追加命令：a命令 sed ‘/^hello/a\—&gt;this is a example’ sed.txt ## ‘—&gt;this is a example’被追加到以hello开头的行(另起一行)后面，sed要求命令a后面有一个反斜杠。 插入：i命令 sed ‘/will/i\some thing new ————————-‘ sed.txt ## 如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。 下一个：n命令 sed ‘/hello/{n; s/aa/bb/;}’ sed.txt 替换下一行的第一个aa sed ‘/hello/{n; s/aa/bb/g;}’ sed.txt 替换下一行的全部aa ## 如果hello被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。 退出：q命令 sed ‘10q’ sed.txt ## 打印完第10行后，退出sed。 同样的写法： sed -n ‘1,10p ‘ sed.txt awk(报表生成器)Awk是一个强大的处理文本的编程语言工具，其名称得自于它的创始人Alfred Aho、Peter Weinberger和Brian Kernighan 姓氏的首个字母，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。简单来说awk就是扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。 语法12awk [options] 'script' var=value file(s)awk [options] -f scriptfile var=value file(s) … TODO 待补充 实例 假设last -n 5的输出如下: 123456root@cts1:~ # last -n 5root pts/1 192.168.170.1 Mon May 28 09:28 still logged inroot pts/1 192.168.170.1 Sun May 27 20:53 - 07:21 (10:28)root pts/0 192.168.170.1 Sun May 27 19:39 still logged inreboot system boot 2.6.32-573.el6.x Sun May 27 19:34 - 14:48 (19:13)root pts/1 192.168.170.1 Sat May 26 20:43 - 22:36 (01:53) 只显示五个最近登录的账号： 12345678root@cts1:~ # last -n 5 | awk '&#123;print $1&#125;'rootrootrootrebootroot# awk工作流程是这样的：读入有'\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是"空白键" 或 "[tab]键",所以$1表示登录用户，$3表示登录用户ip,以此类推 显示/etc/passwd的账户： 12345678root@cts1:~ # cat /etc/passwd | awk -F':' '&#123;print $1&#125;'rootbindaemon...# 这种是awk+action的示例，每行都会执行action&#123;print $1&#125;。# -F指定域分隔符为':' 显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割 12345root@cts1:~ # cat /etc/passwd | awk -F':' '&#123;print $1"\t"$7&#125;'root /bin/zshbin /sbin/nologindaemon /sbin/nologin... BEGIN and END 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。 123456789101112131415161718root@cts1:~ # cat /etc/passwd |awk -F ':' 'BEGIN &#123;print "name,shell"&#125; &#123;print $1","$7&#125; END &#123;print "blue,/bin/nosh"&#125;'---name,shellroot,/bin/zshbin,/sbin/nologin...mysql,/bin/bashblue,/bin/nosh-------------------------root@cts1:~ # cat /etc/passwd | awk -F ':' 'BEGIN &#123;print "name \t shell"&#125; &#123;print$1"\t"$7&#125; END &#123;print "blue,/bin/bash"&#125;'---name shellroot /bin/zshbin /sbin/nologin...mysql /bin/bashblue,/bin/bash awk工作流程是这样的：先执行BEGIN，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录••••••直到所有的记录都读完，最后执行END操作。 搜索/etc/passwd有root关键字的所有行 1234567891011121314151. root@cts1:~ # awk -F: '/root/' /etc/passwd --- root:x:0:0:root:/root:/bin/zsh operator:x:11:0:operator:/root:/sbin/nologin # 这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。2. 搜索支持正则，例如找root开头的: awk -F: '/^root/' /etc/passwd# 搜索/etc/passwd有root关键字的所有行，并显示对应的shellroot@cts1:~ # awk -F ':' '/root/&#123;print $7&#125;' /etc/passwd/bin/zsh/sbin/nologin# 这里指定了action&#123;print $7&#125; awk常见内置变量 FILENAME：awk浏览的文件名 FNR：浏览文件的记录数，也就是行数。awk是以行为单位处理的，所以每行就是一个记录 NR：awk读取文件每行内容时的行号 NF：浏览记录的域的个数。可以用它来输出最后一个域 FS：设置输入域分隔符，等价于命令行-F选项 OFS：输出域分隔符 统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容 1234root@cts1:~ # awk -F ':' '&#123;print "filename:" FILENAME ",linenumber:" NR ",columns:" NF ",linecontent:"$0&#125;' /etc/passwd---filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/zshfilename:/etc/passwd,linenumber:2,columns:7,linecontent:bin:x:1:1:bin:/bin:/sbin/nologin 使用printf替代print,可以让代码更加简洁，易读 1234root@cts1:~ # awk -F ':' '&#123;printf("filename:%s,linenumber:%s,columns:%s,linecontent:%s\n",FILENAME,NR,NF,$0)&#125;' /etc/passwd---filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/zshfilename:/etc/passwd,linenumber:2,columns:7,linecontent:bin:x:1:1:bin:/bin:/sbin/nologin 指定输入分隔符，指定输出分隔符： 12345root@cts1:~ # awk 'BEGIN &#123;FS=":"; OFS="\t"&#125; &#123;print $1, $2&#125;' /etc/passwd---root xbin x... 实用例子 1234567891011121314# A：打印最后一列：awk -F: '&#123;print $NF&#125;' /etc/passwdawk -F: '&#123;printf("%s\n",$NF);&#125;' /etc/passwd# B：统计文件行数：awk 'BEGIN &#123;x=0&#125; &#123;x++&#125; END &#123;print x&#125;' /etc/passwd# C：打印9*9乘法表：awk 'BEGIN&#123;for(n=0;n++&lt;9;)&#123;for(i=0;i++&lt;n;)printf i"*"n"="i*n" ";print ""&#125;&#125;'awk 'BEGIN &#123;for(i=1;i&lt;=9;i++)&#123;for(j=1;j&lt;=i;j++)&#123;printf i"*"j"="i*j" ";&#125;print ""&#125;&#125;'awk 'BEGIN &#123;for(i=9;i&gt;=1;i--)&#123;for(j=i;j&gt;=1;j--)&#123;printf i"*"j"="i*j" ";&#125;print ""&#125;&#125;'# D: 计算1-100 之和echo "sum" | awk 'BEGIN &#123;sum=0;&#125; &#123;i=0;while(i&lt;101)&#123;sum+=i;i++&#125;&#125; END &#123;print sum&#125;' 更多详细用法参见官网 find功能： 搜索文件目录层次结构 格式： find path -option actions find &lt;路径&gt; &lt;选项&gt; [表达式] 常用可选项：1234567891011121314151617-name 根据文件名查找，支持(\'\* \' , \'? \')-type 根据文件类型查找(f-普通文件，c-字符设备文件，b-块设备文件，l-链接文件，d-目录)-perm 根据文件的权限查找，比如 755-user 根据文件拥有者查找-group 根据文件所属组寻找文件-size 根据文件小大寻找文件-o 表达式 或-a 表达式 与-not 表达式 非 类型参数列表：1234567- **f** 普通文件- **l** 符号连接- **d** 目录- **c** 字符设备- **b** 块设备- **s** 套接字- **p** Fifo 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[linux@linux txt]$ ll ## 准备的测试文件total 248-rw-rw-r--. 1 linux linux 235373 Apr 18 00:10 hw.txt-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 LINUX.pdf-rw-rw-r--. 1 linux linux 3 Apr 22 05:50 liujialing.jpg-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 mingxing.pdf-rw-rw-r--. 1 linux linux 57 Apr 22 04:40 mingxing.txt-rw-rw-r--. 1 linux linux 66 Apr 22 05:15 sort.txt-rw-rw-r--. 1 linux linux 214 Apr 18 10:08 test.txt-rw-rw-r--. 1 linux linux 24 Apr 22 05:27 uniq.txt[linux@linux txt]$ find /home/linux/txt/ -name "*.txt" ## 查找文件名txt结尾的文件/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt## 忽略大小写查找文件名包含linux[linux@linux txt]$ find /home/linux/txt -iname "*linux*" /home/linux/txt/LINUX.pdf## 查找文件名结尾是.txt或者.jpg的文件[linux@linux txt]$ find /home/linux/txt/ \( -name "*.txt" -o -name "*.jpg" \) /home/linux/txt/liujialing.jpg/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt另一种写法：find /home/linux/txt/ -name "*.txt" -o -name "*.jpg"# 使用正则表达式的方式去查找上面条件的文件：[linux@linux txt]$ find /home/linux/txt/ -regex ".*\(\.txt\|\.jpg\)$"/home/linux/txt/liujialing.jpg/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt## 查找.jpg结尾的文件，然后删掉[linux@linux txt]$ find /home/linux/txt -type f -name "*.jpg" -delete[linux@linux txt]$ lltotal 248-rw-rw-r--. 1 linux linux 235373 Apr 18 00:10 hw.txt-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 LINUX.pdf-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 mingxing.pdf-rw-rw-r--. 1 linux linux 57 Apr 22 04:40 mingxing.txt-rw-rw-r--. 1 linux linux 66 Apr 22 05:15 sort.txt-rw-rw-r--. 1 linux linux 214 Apr 18 10:08 test.txt-rw-rw-r--. 1 linux linux 24 Apr 22 05:27 uniq.txt 3. Shell操作字符串字符串截取Linux中操作字符串，也是一项必备的技能。其中尤以截取字符串更加频繁，下面为大家介绍几种常用方式，截取字符串 预先定义一个变量：WEBSITE=’http://hadoop//centos/huangbo.html&#39; #截取，*任意的, 删除//左边字符串（包括制定的分隔符），保留右边字符串 root@cts1:~ # echo ${WEBSITE#*//}hadoop//centos/huangbo.html ##截取，删除左边字符串（包括指定的分隔符），保留右边字符串，和上边一个#不同的是，它一直找到最后，而不是像一个#那样找到一个就满足条件退出了。 root@cts1:~ # echo ${WEBSITE##*//}centos/huangbo.html %截取，删除右边字符串（包括制定的分隔符），保留左边字符串 root@cts1:~ # echo ${WEBSITE%//*}http://hadoop %%截取，删除右边字符串（包括指定的分隔符），保留左边字符串，和上边一个%不同的是，它一直找到最前，而不是像一个%那样找到一个就满足条件退出了。 root@cts1:~ # echo ${WEBSITE%%//*}http: 从左边第几个字符开始，以及截取的字符的个数 root@cts1:~ # echo ${WEBSITE:2:2}tp 从左边第几个字符开始，一直到结束 root@cts1:~ # echo ${WEBSITE:2}tp://hadoop//centos/huangbo.html 从右边第几个字符开始，以及字符的个数, 从-4开始, 还是往右边截取 root@cts1:~ # echo ${WEBSITE:0-4:2 ht 从右边第几个字符开始，一直到结束 root@cts1:~ # echo ${WEBSITE:0-4}html 利用awk进行字符串截取 echo $WEBSITE | awk ‘{print substr($1,2,6)}’ ttp:// 利用cut进行字符串截取 root@cts1:~ # echo $WEBSITE | cut -b 1-4 http 获取最后几个字符 root@cts1:~ # echo ${WEBSITE:(-3)} tml 截取从倒数第3个字符后的2个字符 root@cts1:~ # echo ${WEBSITE:(-3):2}tm 字符串替换使用格式 ${parameter/pattern/string} 例子12345678910# 定义变量VAR：[linux@linux ~]$ VAR="hello tom, hello kitty, hello xiaoming"# 替换第一个hello, 用`/`：[linux@linux ~]$ echo $&#123;VAR/hello/hi&#125;hi tom, hello kitty, hello xiaoming# 替换所有hello, 用'//'：[linux@linux ~]$ echo $&#123;VAR//hello/hi&#125;hi tom, hi kitty, hi xiaoming 获取字符串长度在此为大家提供五种方式获取某字符串的长度 123456789101112131415161718192021222324252627282930313233343536# 在此为大家提供五种方式获取某字符串的长度# 1. 使用wc -L命令+----------------------------------------------------+| echo $&#123;WEBSITE&#125; |wc -L || || 35 |+----------------------------------------------------+# 2. 使用expr的方式去计算+---------------------------------------------------+| expr length $&#123;WEBSITE&#125; || || 35 |+---------------------------------------------------+# 3. 通过awk + length的方式获取字符串长度+---------------------------------------------------------------------------+|echo $&#123;WEBSITE&#125; | awk '&#123;print length($0)&#125;' || || 35 |+---------------------------------------------------------------------------+# 4. 通过awk的方式计算以**\"\"**分隔的字段个数+-------------------------------------------------------------------------+| echo $&#123;WEBSITE&#125; |awk -F "" '&#123;print NF&#125;' || || 35 |+-------------------------------------------------------------------------+# 5. 通过\#的方式获取字符串（最简单，最常用）+----------------------------------------------+| echo $&#123;#WEBSITE&#125; || || 35 |+----------------------------------------------+ 4. 脚本自动安装MySql这里先做个记录, 之后会整理一份更详细的文档出来.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bash## auto install mysql## 假如是第二次装，那么要先停掉服务，并且卸载之前的mysqlservice mysql stopEXISTS_RPMS=`rpm -qa | grep -i mysql`echo $&#123;EXISTS_RPMS&#125;for RPM in $&#123;EXISTS_RPMS&#125;do rpm -e --nodeps $&#123;RPM&#125;done## 删除残留文件rm -fr /usr/lib/mysqlrm -fr /usr/include/mysqlrm -f /etc/my.cnfrm -fr /var/lib/mysql## 从服务器获取安装mysql的rpm包wget http://linux/soft/MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpmwget http://linux/soft/MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 删除之前的密码文件，以免产生干扰rm -rf /root/.mysql_secret## 安装服务器rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 获取到生成的随机密码##PSWD=`cat /root/.mysql_secret | awk -F ':' '&#123;print substr($4,2,16)&#125;'`PSWD=` grep -v '^$' /root/.mysql_secret | awk -F ':' '&#123;print substr($4,2,16)&#125;'`##PSWD=$&#123;PWD:1:16&#125;## 安装客户端rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm## 然后删除刚刚下下来的rpm包rm -rf MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpmrm -rf MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 提示安装的步骤都完成了。echo "install mysql server and client is done .!!!!!!"## 打印出来刚刚生成的mysql初始密码echo "random password is:$&#123;PSWD&#125;"## 开启mysql服务service mysql start# 手动第一次登陆，然后改掉密码[root@hadoop bin]# mysql -uroot -pZjVIWvOGD18bT7oXmysql&gt; set PASSWORD=PASSWORD('root');# 现在就可以写脚本链接mysql进行操作了[root@hadoop bin]# vi initMysql.sh#!/bin/bashmysql -uroot -proot &lt;&lt; EOF GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; FLUSH PRIVILEGES; use mysql; select host, user, password from user;EOF]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-4]]></title>
    <url>%2F2018%2F05%2F28%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[1、Linux shell简介1.1、Shell概述Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。 Shell既是一种命令语言，又是一种程序设计语言： 作为命令语言，它交互式地解释和执行用户输入的命令； 作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。 Shell它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。Shell是用户与内核进行交互操作的一种接口，目前最流行的Shell称为bash Shell（Bourne Again Shell） Shell是一门编程语言(解释型的编程语言)，即shell脚本(就是在用linux的shell命令编程)，Shell脚本程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行 Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本 Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器，可以通过cat /etc/shells命令查看系统中安装的shell，不同的shell可能支持的命令语法是不相同的 sh是Unix 标准默认的shell，由Steve Bourne开发，是Bourne Shell的缩写。 bash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是Bourne Again Shell的缩写。 Shell本身支持的命令并不多，内部命令一共有40个，但是它可以调用其他的程序，每个程序就是一个命令，这使得Shell命令的数量可以无限扩展，其结果就是Shell的功能非常强大，完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。 1.2、Shell基本格式代码写在普通文本文件中，通常以.sh结尾，虽然不是强制要求，但希望大家最好这么做 12345vi helloworld.sh--------------------------#!/bin/bash ## 表示用哪一种shell解析器来解析执行我们的这个脚本程序，这句话只对自执行有效，对于使用sh helloworld.sh无效echo "hello world" ## 注释也可以写在这里 在这里，我们就写好了一个shell脚本，第一行是固定需要的，表明用哪一种shell解析器来执行我们的这个脚本程序。本质上，shell脚本里面的代码都是就是一些流程控制语句加一些特殊语法再加shell**命令**组成。其中，我们可以当做每一个命令就是shell编程当中的关键字。 1.3、Shell执行方式1 、sh 方式或者bash 方式 sh helloworld.sh bash helloworld.sh ## 直接指定用系统默认的bash shell解释执行 2 、source 方式或者. 方式 source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。 功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句 source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。 用法： . helloworld.sh source helloworld.sh 3 、直接执行该脚本文件 可以有两种方式，不过这两种方式的执行，都需要该文件有执行权限 所以在执行之前，我们要更改他的执行权限 1、 切换到该文件所在的路径然后执行命令： ./helloworld.sh 2、 直接以绝对路径方式执行 /home/linux/hellworld.sh 1.4、Shell注释单行注释：Shell脚本中以#开头的代码就是注释 # xxx 多行注释：Shell脚本中也可以使用多行注释：:&lt;&lt;! xxx ! 2、Shell基本语法2.1、变量2.1.1、系统变量Linux Shell中的变量分为“系统变量”和“用户自定义变量” 系统变量可以通过set命令查看，用户环境变量可以通过env查看： 常用系统变量：\$PWD \$SHELL \$USER $HOME 2.1.2、自定义变量12345678910111213141516171819# 1.注意, 变量中间不能有空格A=123 echo $A# 2.变量中间有空格的话要加引号 - 双引号中间可以引用变量 a=zs b="this is $a" echo $b this is zs - 单引号引用变量会原样输出 b='this is $a' echo $b this is $a # 3. 要在变量后直接连接字符, 要用&#123;&#125;把变量括起来 $&#123;变量名&#125;其它字符 echo $&#123;A&#125;ddd helloddd 2.1.3、变量高级用法 撤销变量：unset ABC 声明静态变量：readonly ABC= ‘abc’ 特点是这种变量是只读的，不能unset 在一个 .sh 中. 以绝对路径的形式调另一个 .sh 使用export关键字 export A=”A in a.sh” 意味着把变量提升为当前shell 进程中的全局环境变量，可供其他子shell 程序使用， A 变量就成了a.sh 脚本所在bash 进程的全局变量，该进程的所有子进程都能访问到变量A 通过 . /root/bin/b.sh 或 source /root/bin/b.sh 来调用 总结： a.sh中直接调用b.sh，会让b.sh在A所在的bash进程的“子进程”空间中执行 而子进程空间只能访问父进程中用export定义的变量 一个shell进程无法将自己定义的变量提升到父进程空间中去 source或者“.”号执行脚本时，会让脚本在调用者所在的shell进程空间中执行 2.1.4、反引号赋值 a=`ls -l /root/bin` ##反引号，运行里面的命令，并把结果返回给变量a 另外一种写法： a=$(ls -l /root/bin) 2.1.5、变量有用技巧 形式 说明 ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值 ${var:+word} 如果变量 var 被定义，那么返回word，但不改变 var 的值 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。 若此替换出现在Shell脚本中，那么脚本将停止运行 2.1.6特殊变量 $? 表示上一个命令退出的状态码 $$ 表示当前进程编号 $0 表示当前脚本名称 $n 表示n 位置的输入参数（n**代表数字，n&gt;=1 ）** $# 表示参数的个数，常用于循环 $* 和$@ 都表示参数列表 注意：$*与$@区别 $* 和 $@ 都表示传递给函数或脚本的所有参数** 不被双引号” “包含时 $* 和 $@ 都以\$1 \$2 … \$n 的形式组成参数列表 当它们被双引号” “包含时 “$*“ 会将所有的参数作为一个整体，以”\$1 \$2 … \$n”的形式组成一个整串； $* 会将各个参数分开，以”\$1” “\$2” … “\$n” 的形式组成一个参数列表 2.1.7 变量的其他注意点 使用变量 使用一个定义过的变量, 只需要在变量名前面加 $ 符号 如果变量后面直接跟上了字符串, 就必须要加花括号 推荐给所有变量加上花括号, 这个是好的编程习惯 已定义的非只读变量, 可以被重新定义 2.2、运算符2.2.1、算数运算符]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-2]]></title>
    <url>%2F2018%2F05%2F27%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[1.. VI文本编辑器学会使用vi编辑器是学习Linux系统的必备技术之一，因为一般的Linux服务器是没有GUI界面的，Linux运维及开发人员基本上都是通过命令行的方式进行文本编辑或程序编写的。vi编辑器是Linux内置的文本编辑器，几乎所有的类unix系统中都内置了vi编辑器，而其它编辑器则不一定，另外很多软件会调用vi编辑进行内容编写，例如crontab定时任务。较之于其它编辑器或GUI编辑器，vi编辑速度是最快的。VIM是它的增强版本，VI有三种基本工作模式，分别是： 命令模式（command mode）、或者叫一般模式 插入模式（insert mode）、或者叫编辑模式 底行模式（last line mode）、或者叫命令行模式 1. 最基本用法 1、首先会进入“一般模式”，此模式只接受各种命令快捷键，不能编辑文件内容 2、按i键，就会从一般模式进入编辑模式，此模式下，敲入的都是文件内容 3、编辑完成之后，按Esc键退出编辑模式，回到一般模式 4、再按：，进入“底行命令模式”，输入wq命令，回车即可保存退出 2. 移动光标 (一般模式) 1、 使用上下左右键可以移动光标 2、 使用h,j,k,l，依次是向左，下，上，右移动 3、 w：将光标移动到下一个单词的首字母处 4、 W：利用空格向后移动光标，就是忽略标点 5、 b：利用word包括标点向前移动光标, 与w相对应 6、 B：利用空格向前移动光标，忽略标点 7、 e：将光标移动到下一个word的尾部，包括符号 8、 E: 将光标移动到下一个空格分隔字的尾部 9、 (：移动到句子开始 10、 )：移动到句子结束 11、 0：移动光标到本句句首 12、 $：移动光标到本行行尾 13、 {：移动到段落开始 14、 }：移动到段落结束 15、 H：屏幕顶端 16、 L：屏幕底端 17、 M：移动到屏幕中央位置 18、 gg：直接跳到文件的首行行首 19、 G：直接跳到文件的末行行首 20、 最强光标移动： % : 匹配括号移动，包括(, {, [.（你需要把光标先移到括号上） *: 匹配光标当前所在的单词，移动光标到下一个匹配单词 #: 匹配光标当前所在的单词，移动光标到上一个匹配单词 重点总结: h l : 左右, j k : 下上. w: 下一个单词 , b: 上一个单词. 0: 本行行首, $: 本行行尾 (: 句子开始, ): 句子结束 {: 段落开始 }: 段落结束 gg: 文件行首 G: 文件行尾 %: 下一个括号 *: 下一个单词 #: 上一个单词 3. 常用操作(一般模式 &gt;&gt; 插入模式) 单位 指令1 指令2 当前位 前一位/后一位 i: 在光标前一位开始插入 a: 光标后一位开始插入 当前行 最前/最后 I: 在该行的最前面插入 A: 在该行的最后插入 当前行 上一行/下一行 o: 小o, 当前行的下一行插入空行 O: 大o, 当前内容下移一行, 当前行插入空行 当前行 删除 dd: 删除当前行 3dd: ndd, 删除从当前行开始的 n行 当前行 复制 yy: 复制光标所在行 3yy: 复制从当前行开始的3行 粘贴 p: 粘贴到光标所在行的下一行 撤销 u: undo 撤销操作, 可一直撤销到最前面 重点总结: i : 当前光标前开始插入; a: 光标后一位开始插入 I: 在该行的最前面插入; A: 在该行的最后插入 o: 小o, 当前行的下一行插入空行 O: 大o, 当前内容下移一行, 当前行插入空行 dd: 删除当前行 3dd: ndd, 删除从当前行开始的 n行 yy: 复制光标所在行 3yy: 复制从当前行开始的3行 p: 粘贴到光标所在行的下一行 u: undo 撤销操作, 可一直撤销到最前面 4. 查找并替换 在底行命令模式中输入 1. 显示行号 :set nu 2. 隐藏行号 :set nonu 3 .查找关键字 :/you ## 效果：查找文件中出现的you，并定位到第一个找到的地方，按 n可以定位到下一个匹配位置（按N定位到上一个） 查询的时候被匹配上的字符串会被高亮，可以在命令模式下使用:noh取消高亮 4. 直接跳转到 3行 : 3 5. 替换操作 :1 s/sad/bbb 将第一行的第一个sad替换为bbb :1,5 s/sad/bbb 将第一行到第五行的第一个sad替换为bbb :1,. s/sad/bbb 将第一行到光标行的第一个sad替换为bbb :.,$ s/sad/bbb 将光标行到缓冲区最后一行的sad替换为bbb :s/sad/bbb 查找光标所在行的第一个sad，替换为bbb :s/sad/bbb/g 查找光标所在行的所有sad，替换为bbb :%s/sad/bbb 查找文件中所有行第一次出现的sad，替换为bbb :%s/sad/bbb/g 查找文件中所有的sad，替换为bbb 6. 屏幕翻滚类命令 Ctrl + u：向文件首翻半屏 Ctrl + d：向文件尾翻半屏 Ctrl + f：向文件尾翻一屏 Ctrl＋b：向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部 7. 其它的小技巧 r 替换光标处一个字符 R 进入替换模式，从光标处连续替换 s 删除当前字符，进入插入模式 S 删除当前行，进入插入模式 ≈ dd, dd也会删除当前行, 但是不会进入插入模式 f s 光标行内向后查找第一个出现的字符s (先输f , 再输 s, 向后找 s) F s 光标行内向前查找第一个出现的字符s (先输F , 再输 s, 向前找 s) ~ 大小写转换，只转换光标处字符 8. 速查网址 vim详解 2.. 网络管理ifconfig命令ifconfig命令主要用于配置网络接口，如果不加任何参数，则ifconfig命令用于查看当前所有活动网络接口的状态信息，如下图： eth0 表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:0C:29:D6:C7:0E。 inet addr 用来表示网卡的IP地址，此网卡的IP地址是192.168.179.6，广播地址192.168.170.255，掩码地址Mask:255.255.255.0。 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回坏地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。 ifconfig其他常用使用 -a 显示所有网络接口，包括停用的 -s 短格式显示网络信息，同netstat -i -v 显示详细信息，在网络出错的情况下适用 interface 指定网络接口 up 启用网络接口 down 关闭网络接口 启动关闭指定网卡&amp; 常用操作： 12345ifconfig eth0 up #启动网卡ifconfig eth0 down #关闭网卡 ifconfig #处于激活状态的网络接口ifconfig -a #所有配置的网络接口，不论其是否激活ifconfig eth0 #显示eth0的网卡信息 网络配置1. 三种通信模式Vmware中的虚拟机和宿主机进行通信有三种网络方式，它们分别是： Bridged （桥接模式） NAT （网络地址转换模式） Host-Only （仅主机模式） Bridged （桥接模式） 桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致 Host-Only （仅主机模式）宿主 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 NAT 模式 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。 2. NAT网络模式的配置见Linux学习笔记3, 第8条: Linux虚拟主机集群测试环境基本搭建 3. 其它的常用网络管理命令 ping命令: 常用来测试网络连接是否正常 先确定能ping通 ping www.baidu.com host命令: host命令用来进行DNS查询 然后用host命令可以查看到 host www.baidu.com 然后通过浏览器访问该地址：119.75.213.61 netstat命令: netstat命令可以显示网络接口的很多统计信息，包括打开的socket和路由表 以下是常用命令选项 123456789101112-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令 例子 1、列出所有端口，包括监听和未监听的：netstat -a 2、列出所有TCP端口：netstat -at 3、列出所有UDP端口：netstat -au 4、列出所有监听状态的TCP端口：该命令最重要用来查看哪个程序占用了哪个网络端口号 123# 比如查看谁占用了 tcp 的80 端口netstat -nltp | grep 80 [23:04:54]tcp 0 0 :::80 :::* LISTEN 3890/httpd 4. 防火墙防火墙根据配置文件/etc/sysconfig/iptables来控制本机的“出、入”网络访问行为 其对行为的配置策略有四个策略表 基础必备技能 | 查看防火墙状态 | service iptables status || ———————- | ————————– || 开启防火墙 | service iptables start || 关闭防火墙 | service iptables stop || 关闭防火墙开机自启 | chkconfig iptables off || 设置防火墙开机自启 | chkconfig iptables on | 扩展知识 1234567891011121314151617181920212223242526# 1、列出iptables规则iptables -L -n# 列出iptables规则并显示规则编号iptables -L -n --line-numbers# 2、列出iptables nat表规则（默认是filter表）iptables -L -n -t nat# 3、清除默认规则（注意默认是filter表，如果对nat表操作要加-t nat）#清除所有规则iptables -F#重启iptables发现规则依然存在，因为没有保存service iptables restart#保存配置service iptables save# 4、禁止SSH登陆（如果服务器在机房，一定要小心）iptables -A INPUT -p tcp --dport 22 -j DROP# 5、删除规则iptables -D INPUT -p tcp --dport 22 -j DROP # 6、加入一条INPUT规则开放80端口 iptables -I INPUT -p tcp --dport 80 -j ACCEPT 3. Linux系统启动级别管理使用runlevel命令可以查看系统运行的级别 12runlevel [23:12:37]N 3 修改系统默认启动级别 1234567891011121314# 启动级别在这个路径查看vi /etc/inittab-------------------# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault: id:3:initdefault: ## 配置默认启动级别 ## 通常将默认启动级别设置为：3 4. 用户和组1. 用户和组的概念Linux是一个多任务多用户的操作系统，当我们在使用ls -l命令的时候我们看到如下信息： 123drwxrwxr-x. 2 root root 4096 5月 24 00:15 test-rw-r--r--. 1 root root 58 5月 25 11:00 test.sh-rwxr-xr-x. 1 root root 35 5月 23 23:55 test.txt test：表示文件或者目录，具体的文件类型是由该行最前面的那个符号表示 12345- 当为[ *d* ]则是目录- 当为[ *-* ]则是文件；- 若是[ *l* ]则表示为链接文档(link file)；- 若是[ *b* ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；- 若是[ *c* ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置); drwxrwxr-x ：该文件的类型和权限信息 2 ：链接数，如果是文件则是1 ， 如果是文件夹则表示该文件夹下的子文件夹个数 第一个root ：文件或者目录的所属者** 第二个root ：所属用户组** 4096 ：文件或者目录的大小，是目录的话一般都是4096 5月 24 00:15：文件的最后编辑时间 通过以上信息得知，每个文件都设计到用户和组的权限问题 在Linux中，用户是能够获取系统资源的权限的集合，组是权限的容器 Linux 用户类型 用户类型 描述 管理员root 具有使用系统所有权限的用户,其UID 为0 系统用户 保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间 普通用户 即一般用户,其使用系统的权限受限,其UID为500-60000之间. 与Linux用户信息相关的文件有两个：分别是/etc/passwd和 /etc/shadow 123456789101112# 查看文件/etc/passwd文件的内容，选取第一行：root:x:0:0:root:/root:/bin/bashroot:用户名x:密码占位符，密码保存在shadow文件内0:用户id，UID0:组id，GIDroot:注释信息/root:用户家目录/bin/bash:用户默认使用shell登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 Linux用户组类型 用户组类型 描述 系统组 一般加入一些系统用户 普通用户组 可以加入多个用户 私有组/基本组 当创建用户时,如果没有为其指明所属组，则就为其定义一个私有的用户组，起名称与用户名同名，当把其他用户加入到该组中，则其就变成了普通组 与Linux用户组信息相关的文件有两个：分别是/etc/group和 /etc/gshadow 12345# 查看文件/etc/group文件内容，选取一个普通组行：hadoop:x:500:hadoop:组名x:组密码占位符500:组id 2. 用户操作Linux中的用户管理主要涉及到用户账号的添加、删除和修改。所有操作都影响/etc/passwd中的文件内容 添加用户 useradd spark usermod -G bigdata spark ## 设置组 usermod -c “mylove spark” spark ## 添加备注信息 一步完成：useradd -G bigdata -c “mylove” spark 设置密码 passwd spark 根据提示设置密码即可 修改用户 修改spark登录名：usermod -l spark storm 将spark添加到bigdata和root组：usermod -G root,bigdata spark 查看spark的组信息：groups spark 删除用户 userdel -r spark 加一个-r就表示把用户及用户的主目录都删除 3. 组操作前面我们知道，组是权限的集合。在linux系统中，每个用户都有一个用户组，没有指定时都默认为私有组，私有组名同用户名一致，建立用户组的好处是系统能对一个用户组中的所有用户的操作权限进行集中管理。组管理涉及组的添加、删除和修改。组的增加、删除和修改实际上就对/etc/group文件的更新 添加一个叫bigdata的组 groupadd bigdata 查看系统当前有那些组 cat /etc/group 将hadoop用户添加到bigdata组中 usermod -G bigdata spark 或者 gpasswd -a spark bigdata 这两个命令的区分记忆技巧： 命令是什么，就证明对什么做操作，所以最后的参数就是命令的操作对象，中间的可选项表示要干嘛 将spark用户从bigdata组删除 gpasswd -d spark bigdata 将bigdata组名修改为bigspark groupmod -n bigspark bigdata 删除组 groupdel bigdata 4. 为用户配置sudoer权限普通情况下，使用普通用户进行一些简单的操作就OK，但是普通用户和root用户的区别就在于root用户能对系统做任何事，但是普通用户就不行。处处受限。那么假如在某些情况下，普通用户想拥有更大的权限做更多的事情，虽然有权限限制，但也不是不可以。部分操作还是可以赋予更高的权限让普通用户做一次。这就需要给普通用户配置root权限了。意思就是让普通用户使用root权限去做一些操作，这当然是需要配置的。 用root编辑 vi /etc/sudoers 在文件的如下位置，为hadoop添加一行即可 root ALL=(ALL) ALL hadoop ALL=(ALL) ALL spark ALL=(ALL) ALL 然后，hadoop用户和spark用户就可以用sudo来执行系统级别的指令 [hadoop\@hadoop01 ~]\$ sudo useradd huangxiaoming 5. 切换用户在linux的系统使用过程当中，免不了会有多个用户来回切换使用。 所以在此提供切换用户的使用操作：切换用户使用的命令是 su（switch user） 从普通用户切换到root用户 , 需要输密码 su root 或 su 从root用户切换到普通用户, 不需要输密码 su xxx 5. 文件权限1、linux文件权限的描述格式解读Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內 linux文件的用户权限的分析图 123456 -rw-r--r-- 1 user staff 651 Oct 12 12:53 .gitmodules# ↑╰┬╯╰┬╯╰┬╯# ┆ ┆ ┆ ╰┈ 0 其他人# ┆ ┆ ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ g 属组# ┆ ╰┈┈┈┈ u 属主# ╰┈┈ 第一个字母 `d` 代表目录，`-` 代表普通文件 d：标识节点类型（d：文件夹 -：文件 l：链接） r：可读 w：可写 x：可执行 文件 文件夹 r 可读取内容 可以ls w 可修改文件的内容 可以在其中创建或者删除子节点 x 能否运行这个文件 能否cd**进入这个目录** 2、 修改文件权限chmod命令 用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 语法12345chmod(选项)(参数)r=读取属性 //值＝4 w=写入属性 //值＝2 x=执行属性 //值＝1 选项： u User，即文件或目录的拥有者；g Group，即文件或目录的所属群组；o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a All，即全部的用户，包含拥有者，所属群组以及其他用户；r 读取权限，数字代号为“4”;w 写入权限，数字代号为“2”；x 执行或切换权限，数字代号为“1”；- 不具任何权限，数字代号为“0”；s 特殊功能说明：变更文件或目录的权限。 参数: 权限模式：指定文件的权限模式；文件：要改变权限的文件。 示例修改文件权限 1234567891011# 直接修改chmod g-rw haha.dat ## 表示将haha.dat对所属组的rw权限取消chmod o-rw haha.dat ## 表示将haha.dat对其他人的rw权限取消chmod u+x haha.dat ## 表示将haha.dat对所属用户的权限增加xchmod a-x haha.dat ## 表示将haha.dat对所用户取消x权限# 也可以用数字的方式来修改权限(常用)chmod 664 haha.dat就会修改成 rw-rw-r--如果要将一个文件夹的所有内容权限统一修改，则可以-R参数chmod -R 770 aaa/ 修改文件所有权 1234# &lt;只有root权限能执行&gt;chown angela aaa ## 改变所属用户chown :angela aaa ## 改变所属组chown angela:angela aaa/ ## 同时修改所属用户和所属组 6. 压缩打包gzipgzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。 gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。 语法 gzip (选项) (参数) 选项 123456789101112131415161718-a或——ascii：使用ASCII文字模式；-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；-N或——name：压缩文件时，保存原来的文件名称及时间戳记；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；--best：此参数的效果和指定“-9”参数相同；--fast：此参数的效果和指定“-1”参数相同。-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。 参数 文件列表：指定要压缩的文件列表。 示例 12345678910111213# 把test6目录下的每个文件压缩成.gz文件gzip *# 把上例中每个压缩的文件解压，并列出详细的信息gzip -dv *# 详细显示例1中每个压缩的文件的信息，并不解压gzip -l *# 压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gzgzip -r log.tar# 递归的压缩目录gzip -rv test6# 这样，所有test下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。# 递归地解压目录gzip -dr test6 bzipbzip2命令 用于创建和管理（包括解压缩）“.bz2”格式的压缩包。 语法 bzip2 (选项) (参数) 选项 123456789101112-c或——stdout：将压缩与解压缩的结果送到标准输出；-d或——decompress：执行解压缩；-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；-h或——help：在线帮助；-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；-s或——small：降低程序执行时内存的使用量；-t或——test：测试.bz2压缩文件的完整性；-v或——verbose：压缩或解压缩文件时，显示详细的信息；-z或——compress：强制执行压缩；-V或——version：显示版本信息；--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。 参数 文件：指定要压缩的文件。 示例 1234567891011## 压缩指定文件filename:bzip2 filename 或 bzip2 -z filename## 解压指定的文件filename.bz2:bzip2 -d filename.bz2 或 bunzip2 filename.bz2# 压缩解压的时候将结果也输出：bzip2 -v filename filename: 0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.# 压缩解压的时候，除了生成结果文件，将原来的文件也保存: bzip2 -k filename# 解压到标准输出, 输出文件的内容bzip2 -dc filename.bz2 tarLinux下的归档使用工具，用来打包和备份。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 其实最简单的使用 tar 就只要记忆底下的方式即可： tar.gz 格式: 1234# 一次性打包并压缩、解压并解包打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]解压并解包： tar -zxvf [原文件名].tar.gz注：z代表用gzip算法来压缩/解压。 tar.bz2格式: 1234# 一次性打包并压缩、解压并解包打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]解压并解包： tar -jxvf [原文件名].tar.bz2注：小写j代表用bzip2算法来压缩/解压。 其实用不到的话就不用看了, 下面的. 语法 tar(选项)(参数) 选项 1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 参数 文件或目录：指定要打包的文件或目录列表。 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 12345- z：有gzip属性的- j：有bz2属性的- Z：有compress属性的- v：显示所有过程- O：将文件解开到标准输出 实例 zip格式 123压缩： zip -r [目标文件名].zip [原文件/目录名]解压： unzip [原文件名].zip注： -r参数代表递归 tar格式（该格式仅仅打包，不压缩） 123打包：tar -cvf [目标文件名].tar [原文件名/目录名]解包：tar -xvf [原文件名].tar注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。 tar.gz格式(方式二常用) 12345678# 方式一：利用前面已经打包好的tar文件，直接用压缩命令。压缩：gzip [原文件名].tar解压：gunzip [原文件名].tar.gz# 方式二：一次性打包并压缩、解压并解包打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]解压并解包： tar -zxvf [原文件名].tar.gz注：z代表用gzip算法来压缩/解压。 tar.bz2格式 12345678方式一：利用已经打包好的tar文件，直接执行压缩命令：压缩：bzip2 [原文件名].tar解压：bunzip2 [原文件名].tar.bz2方式二：一次性打包并压缩、解压并解包打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]解压并解包： tar -jxvf [原文件名].tar.bz2注：小写j代表用bzip2算法来压缩/解压。 jar格式 12345678910压缩：jar -cvf [目标文件名].jar [原文件名/目录名]解压：jar -xvf [原文件名].jar# 注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：Manifest-Version: 1.0Created-By: 1.6.0_27 (Sun Microsystems Inc.)Main-class: the_name_of_the_main_class_should_be_put_here# 然后用如下命令打包：jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名] 这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static void main方法了。 7z格式 12345压缩：7z a [目标文件名].7z [原文件名/目录名]解压：7z x [原文件名].7z注：这个7z解压命令支持rar格式，即：7z x [原文件名].rar 其它例子 参考网址 7. Linux开关机和重启 开机：开机键 关机：shutdown，halt，init 0，poweroff 重启：reboot，init 6 Shutdown命令详解： shutdown -h now ## 立刻关机 shutdown -h +10 ## 10分钟以后关机 shutdown -h 12:00:00 ##12点整的时候关机]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-1]]></title>
    <url>%2F2018%2F05%2F26%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[1&gt; 初识Linux1. Linux介绍Linux系统是一套免费使用和自由传播的类UNIX操作系统（主要用在服务器上），是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了UNIX以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 UNIX：操作系统，是美国AT&amp;T公司贝尔实验室于1969年完成的操作系统，最早由肯·汤普逊（Ken Thompson），丹尼斯·里奇（Dennis Ritchie）开发。在1971年首次对外发布，刚好在1971，丹尼斯·里奇（Dennis Ritchie）发明了C语言，后来在1973，Unix被他用C语言重新编写。Unix前身源自于MultiCS，叫UniCS，后来改名叫Unix。 POSIX：可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE（电气和电子工程师协会）为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称。 GNU：1983年，Richard Stallman（理查德·马修·斯托曼）创立GNU计划。一套完全自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标（发展出一套完整的开放源代码操作系统来取代Unix），名称来自GNU\’s Not Unix!的递归缩写。 GPL：一种GNU通用公共许可协议，为保证GNU软件可以自由的使用、复制、修改和发布，所有的GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，是一个被广泛使用的自由软件许可协议条款，保证终端用户运行、学习、分享（复制）及编辑软件之自由，GPL是自由软件和开源软件的最流行许可证，特色表现： •取得软件与原始码：您可以根据自己的需求来执行这个自由软件 •复制：您可以自由的复制该软件 •修改：您可以将取得的原始码进行程序修改工作，使之适合您的工作 •再发行：您可以将您修改过的程序，再度的自由发行，而不会与原先的撰写者冲突 •回馈：您应该将您修改过的程序代码回馈于社群 ==不同许可证的区别== 1985年，Richard Stallman又创立了自由软件基金会（Free Software Foundation，FSF）来为GNU计划提供技术、法律以及财政支持。 1990年，GNU计划开发主要项目有Emacs（文本编辑器）、GCC（GUN Compiler Collection，GNU编译器集合）、Bash等，GCC是一套GNU开发的编程语言编译器。还有开发一些UNIX系统的程序库和工具。 Linux操作系统诞生于1991年10月5日（这是第一次正式向外公布时间），与UNIX兼容，并在GPL条款下发布。现在，Linux产生了许多不同的Linux发行版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。 1992年，Linux与其他GUN软件结合，完全自由的GNU/Linux操作系统正式诞生，简称Linux ==Linux的基本思想有两点== 第一，一切都是文件 第二，每个软件都有确定的用途 与Unix思想十分相近。 2. Linux特点1、分时的多用户、多任务操作系统 2、多数网络协议支持、方便的远程管理 3、强大的内存管理和文件系统管理 4、大量的可用的软件和免费的软件 5、优良的稳定性和安全性 6、良好的可移植性和灵活性 7、可供选择的厂商多 3. Linux操作系统架构 补充：linux内核必须加上一个”界面”软件，才能让用户去使用，”界面”分两类： a、命令行界面CLI SHELL（有很多种，最流行的一种是bash shell） b、图形界面GUI SHELL（也有很多种，目前最流行的有两种：gnome和kde） 4. Linux内核严格来讲，Linux不是一个操作系统，Linux只是一个操作系统中的内核。 内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O、进程管理等。 内核官网：[http://www.kernel.org/]{.underline}。目前最新的内核版本：4.13.5 要注意区分linux发型版本和linux内核版本。两者不是同一个事物 下面这位是Linux内核的作者： 这是Linux的logo 5. 常见发行版红帽企业系统（RedHat Enterprise Linux, RHEL） 全球最大的开源技术厂商，全世界内使用最广泛的Linux发布套件， 提供性能与稳定性极强的Linux套件系统并拥有完善的全球技术支持。 官网：[http://www.redhat.com]{.underline} 社区企业操作系统（CentOS） 最初是将红帽企业系统”重新编译/发布”给用户免费使用而广泛使用， 当前已正式加入红帽公司并继续保持免费（随RHEL更新而更新）。 官网：[http://www.centos.org/]{.underline} 红帽用户桌面版（Fedora [Linux]） 最初由红帽公司发起的桌面版系统套件（目前已经不限于桌面版）， 用户可免费体验到最新的技术或工具，而功能成熟后加入到RHEL中。 官网：[http://fedora.redhat.com]{.underline} 国际化组织的开源操作系统（Debian） 提供超过37500种不同的自由软件且拥有很高的认可度， 对于各类内核架构支持性良好，稳定性、安全性强更有免费的技术支持。 官网：[http://www.debian.org/]{.underline} 基于Debian的桌面版（Ubuntu） Ubuntu是一款基于Debian派生的产品，对新款硬件具有极强的兼容能力。 普遍认为Ubuntu与Fedora都是极其出色的LINUX桌面系统。 官网：[http://www.ubuntulinux.org/]{.underline} 当然还有国内的国防科技大学发行麒麟kylin和中科院发行红旗RedFlag 2&gt; Linux文件系统1. CentOS的目录结构 2. 根目录下每个目录的简单解释 /**：**根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中 /bin:/usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等 /boot**：**放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可 /dev**：**存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc**：**系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/gateways、/etc/resolv.conf、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。注：/etc/X11存放与x windows有关的设置 /home**：**系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据 /lib:/lib64:/usr/lib:/usr/local/lib**：**系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /lost+fount**：**系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found /mnt:/media**：**光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载 /opt**：**给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE桌面软件，可以将该软件安装在该目录下。以前的Linux系统中，习惯放置在 /usr/local目录下option /proc**：*此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/等process /root**：**系统管理员root的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 /sbin:/usr/sbin:/usr/local/sbin**：**放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。 /selinux**：**selinux软件目录，用于保证系统安全 /srv**：**服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内service /sys**：**类似于/proc的特殊文件系统，存放内核数据信息 /tmp**：**一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下 /usr**：应用程序存放目录， /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间 usr**：user share resources/unix share resouces /var**：**放置系统执行过程中经常变化的文件，如： /var/log：随时更改的日志文件 /var/log/message：所有的登录文件存放目录 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动 使用建议： 用户应该将文件存储在自己的主目录及其子目录下 系统绝大多数设置都在/etc目录下 不要修改/或者/usr目录下的任何内容，除非你真的清楚你在做什么，也就是说/目录最好和安装好系统之初保持一致 大多数工具和应用软件程序都安装在/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/bin 文件或者目录都有唯一的绝对路径，没有盘符的概念 3&gt; Linux命令终端1. Linux 的命令格式：命令选项 命令参数注意：三者之间要空格隔开，其中命令选项分为长格式和短格式。 短格式用’-‘表示，比如：-l， 长格式用”–”表示，比如：–help， 也可以使用组合格式，比如：-a -l 等价于-la或者-al 2. Linux的默认命令提示符：#：管理员用户 $：普通用户 PS: Linux以回车键表示命令结束，如果 linux命令需要折行输入，那么可以以 \表示每行结束 4&gt; 常用命令归纳分类基本命令 文件管理 mkdir, rmdir, mv, rm, cp, touch, cat, tac, echo, more, less, head, tail, file, find, rename, ln, pwd, scp, alias 磁盘管理 ls, cd, du, df, mount, unmounts, fdisk 文档处理 wc, sort, uniq, cut, sed, awk, grep, vi, diff 用户和组 useradd, usermod, passwd, userdel, groupadd, groupdel, chgrp, su 文件传输 get, put, wget 网络通信 telnet, nc, ifconfig, ping, netstat, ip, host 备份压缩 gzip, bzip2, bunzip2, tar, zip 系统管理 exit, kill, last, ps, top, free, pstree, reboot, halt, shutdown, sudo, who, w, whoami, whereis, which, last, whatis 系统设置 clear, set, unset, hwclock, time, date, 其他 history, hostname, nohup, service, init, rpm, ssh, cal, yum 网站速查http://man.linuxde.net/ http://www.jb51.net/linux/ https://jaywcjlove.github.io/linux-command ps: 直接在命令行中, 用 man xx, 也可以查看命令信息 5&gt; 常用文件系统命令详解磁盘管理 cd change directory 常使用方式： cd sourcedir 进入用户主目录 cd ~ 进入用户主目录 cd - 返回进入此目录之前所在的目录 cd .. 返回上级目录（若当前目录为”/“，则执行完后还在”/“；”..”为上级目录的意思） cd ../.. 返回上两级目录 pwd print working directory pwd 显示当前工作目录 ls list：显示目录内容列表 使用格式：ls 选项 目录或文件名 常用选项 -l：详细信息显示 -a：显示所有子目录和文件的信息，包括隐藏文件 -A：类似于“-a”，但不显示“.”和“..”目录的信息 -R：递归显示内容 -h：以友好方式显示文件大小 例子： ls -l ## 列出文件详细信息， 也可以写作 ll ls -lah ## 以友好方式显示包括隐藏文件的详细信息 du disk usage：显示每个文件和目录的磁盘使用空间 使用格式：du 选项 目录或文件名 常用选项： -a：统计时包括所有的文件，而不仅仅只统计目录 -h：以更易读的字节单位（K、M等）显示信息 -s：只统计每个参数所占用空间总的大小 例子： du -ah ## df disk free：显示磁盘相关信息 常用选项： -h：以更易读的字节单位（K、M等）显示信息 -T：显示分区格式 例子： df -h ## 显示磁盘信息，以友好方式 df -T -h ## 以友好格式显示磁盘信息，并且附加磁盘格式 文件管理 touch 创建空文件 或更新文件时间标记 使用格式： touch 文件名 file 查看文件类型 使用格式： file 文件名 根据文件内容格式判断文件类型。而不是根据后缀名 mkdir 创建文件夹 make directory 使用格式：mkdir 选项 参数 常用选项： -p：已级联的方式创建文件夹 例子： mkdir -p /root/ma/niu/zhu/dagou ## 上级目录不存在自动创建上一级目录，常用 cp 复制文件 使用格式： cp 选项 源文件或目录… 目标文件或目录 常用选项： -r：递归复制整个目录树 -p：保持源文件的属性不变 -i：需要覆盖文件或目录时进行提醒 rm 删除文件或目录 使用格式：rm [选项] 文件或目录 常用选项： -f：强行删除文件或目录，不进行提醒 -i：删除文件或目录时提醒用户确认 -r：递归删除整个目录树 例子： rm -rf /root/ma/ ## 不提醒递归删除整个目录，慎用慎用慎用 mv 移动文件 如果与源文件位置一样，则相当于重命名 使用格式： mv [选项]… 源文件或目录… 目标文件或目录 常用选项： -f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录 -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作 rmdir 删除空文件夹 常用选项： -p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除； rmdir -p /root/aa/bb/cc/dd/ee 删除文件夹ee，如果删除ee后，dd变为空，则删除dd，依次类推 cat 连接文件并打印到标准输出设备上 常用选项： -n或–number：由1开始对所有输出的行数编号 cat /home/hadoop/data.txt ## 查看文件内容 tac 倒序输出文件内容 tac /home/hadoop/data.txt echo 输出指定的字符串或者变量 常用选项： -e：若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： \a 发出警告声； \b 删除前一个字符； \c 最后不加上换行符号； \f 换行但光标仍旧停留在原来的位置； \n 换行且光标移至行首； \r 光标移至行首，但不换行； \t 插入tab； \v 与\f相同； \ 插入\字符； \nnn 插入nnn（八进制）所代表的ASCII字符； 例子： echo ‘ma’ ## 输出ma echo -e ‘ma\n’ ## 打印ma之后换行 echo -ne ‘ma’ ‘zhonghua’ ## 打印完不换行 echo ‘ma’ &gt; ma.dat ## 覆盖 echo ‘ma’ &gt;&gt; ma.dat ## 追加 echo $PWD ## 输出变量内容 head 在屏幕上显示指定文件的开头若干行 默认显示10行 常用选项： -n&lt;数字&gt;：指定显示头部内容的行数； 例子： head -n 5 install.log ## 显示该文件前五行内容 tail 在屏幕上显示指定文件的末尾若干行 常用选项： -f：显示文件最新追加的内容 例子： tail file ## 显示文件file的最后10行 tail +20 file ## 显示文件file的内容，从第20行至文件末尾 tail -c 10 file ## 显示文件file的最后10个字符 tail -f install.log ## 显示最新追加的内容 more 显示文件内容，每次显示一屏 使用方式： 按Space键：显示文本的下一屏内容。 按Enter键：只显示文本的下一行内容。 按h键：显示帮助屏，该屏上有相关的帮助信息。 按b键：显示上一屏内容。 按q键：退出more命令。 less 分屏上下翻页浏览文件内容 和more使用方式基本类似 按e键：向上滚动一行 按y键：向下滚动一行 G：跳到文件末尾 gg：跳到文件首行 ln 用来为文件创件连接 软链接 -s 和 硬链接 ln /mnt/cdrom1 /var/www/html/centos/ —&gt;硬链接 ln -s /mnt/cdrom2 /var/www/html/centos/ –&gt;软链接-符号链接 alias 别名 查看别名：alias 定义别名：alias la=&#39;ll -a 取消别名：unalias la 其它有用的命令123456789101112131415161718man：显示命令帮助信息clear：清屏，或者按ctrl + l也行ctrl + c：退出当前进程ctrl + z：挂起当前前台进程whatis：命令是什么whereis：在标准路径下搜索与名称相关的文件，whereis将所有搜索到的文件都显示which：which在设定的搜索路径下进行目录搜索，只显示搜索到的第一个文件su：切换用户history：显示历史命令hostname：显示主机名set：查看系统变量get：下载文件put：上传文件sudo：以root用户权限执行一次命令exit：退出登录状态w：显示当前连接的用户who：显示当前会话信息uptime：查看系统运行时间 使用小技巧12345678910111213ctrl + u：清除光标前的命令，相当于剪切ctrl + k：清除光标后的命令，相当于剪切ctrl + y：粘贴ctrl + t：把光标前面的那个字符往后挪动一位ctrl + l：清屏!!：执行上一次命令!$：上个命令的最后一个单词ctrl + w：删除光标前一个单词cd data; cat sed.txt：表示先执行cd，然后执行cat，工作目录会切换(cd data; cat sed.txt)：跟上个命令相比，不切换工作目录|：管道符，表示把前面命令内容的输出当做后面命令的输入&gt;：表示内容覆盖&gt;&gt;：表示内容追加]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-3]]></title>
    <url>%2F2018%2F05%2F25%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[1. 系统服务管理 检查本机httpd服务是否开启, 使用命令service httpd status 开启/关闭/重启 httpd服务 service httpd start/stop/restart 查看所有的服务状态 service --status-all 过滤出某个服务service –status-all | grep httpd` 防火墙服务 sevice iptables status/stop/start/restart 配置后台服务进程开机自启 12345# 开启开机自启http进程-&gt; chkconfig httpd on# 查看httpd的开机自启状态-&gt; chkconfig --list | grep httpdhttpd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 缺省系统运行级别 0 为停机，机器关闭。 1 为单用户模式，就像Win9x下的安全模式类似。 2 为多用户模式，但是没有NFS支持。 3 为完整的多用户模式，是标准的运行级。 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本 电脑的电池用尽时，可以切换到这个模式来做一些设置。 5 就是X11，进到X Window系统了。 6 为重启，运行init 6机器就会重启。 Centos中时区 当前正在使用的时d区文件位于 /etc/localtime 其他时区文件则位于 /usr/share/zoneinfo 中国时区使用 /usr/share/zoneinfo/Asia/Shanghai 更改时区 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果没有 Asia/Shanghai 时区文件，请使用tzselect命令去生成时区文件，生成好的时区文件就在 /usr/share/zoneinfo目录下 修改系统时间 date : 直接查看时间 date -s : 手动设置时间 ntpdate time.windows.www : 同步时间服务器时间 2. 简单磁盘管理 df：列出文件系统的整体磁盘使用量 -h 人性化的列出文件的大小等 123-&gt; # df -h /dev/sr0Filesystem Size Used Avail Use% Mounted on/dev/sr0 3.7G 3.7G 0 100% /media/cdrom du：检查磁盘空间使用量 fdisk：用于磁盘分区 3. 文件的基本属性 - TODO前缀的含义 123456# 查看目录的权限-&gt; # ll -d /var/www/html/localyumdrwxr-xr-x. 7 root root 4096 5月 25 07:50 autojump-rw-r--r--. 1 root root 50434 5月 23 10:11 install.loglrwxrwxrwx. 1 root root 13 5月 25 21:04 localyum -&gt; /media/cdrom/ 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置); r、w、x 对于文件和目录的含义 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以再目录中创建、删除文件 x 执行权限 可以执行文件 可以进入目录 4. 软件安装 TODO1. 二进制发布包安装 TODO:软件已经针对具体平台编译打包发布，只要解压，修改配置即可 安装jdk , 安装tomcat也一样 TODO: 通过 ftp工具把 jdk传到 linux服务器 创建一个 /var/www/html/soft/jdk8 的软链接, 指向服务器中的安装包 —— 这一步失败了 #####2. 源码编译安装 TODO: 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署 安装/卸载 redis 卸载: 首先查看redis-server是否启动 ps aux | grep redis 有的话, 关闭这些进程 kill -9 进程pid 删除redis相应的文件夹就可以了。 find / -name redis 安装: 拷贝到/usr/local, 解压, 删掉原安装包 12tar -zxvf redis-3.0.0.tar.gz rm redis-3.0.0.tar.gz 检查运行环境 123# 检测一下是否可以安装makemake test 安装到指定目录 1make PREFIX=/root/apps/redis install 拷贝配置信息 1cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin 启动 前端模式 bin/redis-server 后端模式启动 修改redis.conf配置文件，daemonize yes` 以后端模式启动 : TODO 3. RPM发布包软件已经按照RedHat（Redhat Package Manager）的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用rpm命令进行安装 Mysql安装 1234567891011121314151617181920# rpm安装命令1、安装包：rpm -ivh 包名参数：-i ：安装的意思-v ：可视化-h ：显示安装进度另外在安装一个rpm包时常用的附带参数有：--force 强制安装，即使覆盖属于其他包的文件也要安装--nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包2、升级包：rpm -Uvh filename-U 升级3、卸载包rpm -e filename （这里的filename是通过rpm的查询功能所查询到的）4、查询一个包是否安装：rpm -q 包名（这里的包名，是不带有平台信息以及后缀名的）5.查询当前安装的所有rpm包：rpm -qa查询当前安装的和sql相关的包：rpm -qa | grep 'sql'查询sqlite安装路径：rpm -ql sqlite 5. 设置本地/网络yum源 首先检查虚拟机的 CD/DVD驱动器是否有挂载iso镜像文件 找到挂载源的位置 在 /dev/sr0下, 将其挂载到/mnt下创建的cdrom文件夹下 mount -t iso9660 -o ro /dev/sr0 /mnt/cdrom 配置开机挂载 , vi /etc/fstab, 增加一行 /dev/cdrom /mnt/cdrom iso9660 defaults 0 0 创建软连接, 设置可以通过web访问 ln -s /mnt/cdrom/ /var/www/html/yumsorurce 修改etc/yum.repos.d中的文件entOS-Media.repo中的enabled=1, 开启从本地寻找, 因为文件中, 原本就配置了baseurl: file:///media/cdrom/, 而我们自己创建了media/cdrom这个目录, 所以就可以从这里面读取了 执行yum repolist, 发现已经能读取出media中的repo了, 大功告成 c6-media CentOS-6 - Media 6,575 tips: 个人觉得还是配置个网络源比较好, 比如163/阿里的. 12345678910111213141516171819# 操作步骤# 1.备份原来的Base源cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo_bak# 2. 下载网易/阿里源 到/etc/yum.repos.d下, 替换掉原本的# 网易源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS6-Base-163.repo# 阿里源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoyum clean allyum makecache# yum使用yum update 􏻦􏻧􏷉􏷊升级系统yum install -y xxx 直接安装, 不用确认􏻈yum update ~ 􏻦􏻧􏸻􏹺􏷜 升级指定软件包yum remove ~ 􏺌􏷎􏸻􏹺􏷜􏷕 卸载指定软件 挂载, 配置源的其他说明 12345678910111213141516171819202122232425# 关于挂载# lrwxrwxrwx. 1 root root 3 5月 25 16:47 cdrom -&gt; sr0cdrom其实是sr0的软链接, 因此直接找sr0即可# 挂载的基本语法mont -t iso9660 -o ro(只读) /dev/sr0 /mnt/cdrom (挂载类型) (挂载方式) (挂载源) (挂载点)# 卸载的语法umount /mnt/cdrom 如果卸载时遇到 umount: /mnt/cdrom: device is busy.解决方式: 1. 查找哪个进程在用: fuser /mnt/cdrom 2. 查找进程: ps -ef | grep 进程号 3. 插死进程: kill -9 进程号, 如果是root用户, 可能会断开连接, 需要重连 4. 然后继续 umount, 如果不行, 就强制卸载 umount -f /mnt/cdrom# 关于etc/yum.repos.d 中文件的说明 CentOS-Base.repo：有网的环境下默认使用这个，这个是第一优先级。因为没网，所以修改文件名，设置成备份文件。这样系统就会使用第二优先级的文件。 CentOS-Media.repo：没网的环境下使用这个，在上图中会发现他默认配置了4个路径，第4个yumsource是我自己加的。意思是说，如果系统检测yum使用了离线安装，那么会从上到下从这4个路径中查找安装软件。所以我们只要把光盘挂载在这四个目录下的任意一个目录即可。同时，该配置文件默认是不启用的，如果想使用需要修改倒数第二行的enabled为1，否则该文件无效。 # /mnt &amp; /media 目录的区别media：挂载一些移动设备，例如光盘，U盘等。mnt： 挂载一些硬盘等设备。所以我们的光盘应该挂载在media目录下，从yum给的默认配置文件也能看出。 6. 进程相关1. ps命令ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。 常用选项包括： 123456ps -1、-a显示所有用户的进程2、-u显示用户名和启动时间3、-x显示所有进程，包括没有控制终端的进程4、-e显示所有进程，包括没有控制终端的进程，较x选项，信息更为简略5、-l显示进程详细信息，按长格式显示 常用组合 ps -au 显示所有用户进程，并给出用户名和启动时间等详细信息 ps -aux 显示所有用户进程，包括没有控制终端的进程，并给出用户和和启动埋单等详细信息 ps -el 按长格式显示进程详细信息 1234567891011121314151617181920212223242526272829303132# 上述命令可能出现的字段含义USER: 进程所有者PID: 进程号PPID: 进程的父进程ID%CPU: CPU占用率C: 进程的CPU占用率%MEM: 内存占用率VSZ: 表示如果一个程序完全驻留在内存的话需要占用多少内存空间;RSS: 指明了当前实际占用了多少内存;TTY: 终端的次要装置号码 (minor device number of tty)F：进程的标志S：进程的状态STAT: 该进程程的状态，有以下值D: 不可中断的静止R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的进程N: 低优先序的进程L: 有记忆体分页分配并锁在记忆体内PRI：进程的优先权NI：进程的Nice值ADDR：进程的地址空间SZ：进程占用内存的大小WCHAN：进程当前是否在运行TTY：进程所属终端START: 进程开始时间TIME: 执行的运行时间COMMAND：所执行的指令CMD：进程的命令 2. kill / pidof / pkill 命令有时候某个进程可能会长期占用CPU资源或无法正常执行或超出运行时间等，此时可能希望人工干预直接将进程杀死，这时候kill命令可以派上用场 12341、kill pid 直接杀死进程，但不能保证一定能杀死2、kill -9 pid 强制杀死进程3、pidof命令用于查看某个进程的进程号（例如：pidof mysqld）4、pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉 3. 进程切换前台进程指的是进程在执行时会将命令行阻塞，直到进程执行完毕；后台进程指的是进程在执行时不会阻塞当前命令行，而是在系统后台执行 123451、ctrl + c 终止进程2、ctrl + z 挂起进程3、fg命令将进程转换到前台执行4、bg命令将进程转换到后台执行5、jobs命令查看任务 4. top命令top 命令可以定期显示所有正在运行和实际运行并且更新到列表中，它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。它也会显示内存和 CPU 使用率过高的正在运行的进程。 按q键退出查看. 5. pstree命令将进程间的关系以树结构的形式展示，能清楚看各进程之间的父子关系 12pstree ：以树状形式显示进程pstree -p ： 以树状形式显示进程，并且显示进程号 6. JPS命令JPS命令是JDK提供的一个检查系统是否启动了JVM进程的一个进程。不是linux系统自带的。主要任务就是用来检查java进程的。 7. 计划任务概念计划任务在Linux的体现主要分为at和crontab，其中： at：通过at命令安排任务在某一时刻执行一次 crontab：通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 命令服务管理crontab在CentOS系统上，crontab服务的名称叫做crond 安装 yum -y install crontabs 服务操作说明 1234567891011service crond start #启动服务service crond stop #关闭服务service crond restart #重启服务service crond reload #重新载入配置service crond status #服务状态#查看crontab服务是否已设置为开机启动，执行命令：chkconfig --list#加入开机自动启动：chkconfig --level 35 crond on crontab功能使用 命令格式 123456789101112131415161718192021222324252627282930313233crontab [-u user] filecrontab [-u user] [ -e | -l | -r ]# crontab 参数说明：-u user：用来设定某个用户的crontab服务，例如，”-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。# 命令示例：crontab file [-u user] ## 用指定的文件替代目前的crontab。 # 必须掌握：crontab -l [-u user] ## 列出用户目前的crontab. crontab -e [-u user] ## 编辑用户目前的crontab.# 通过crontab添加的计划任务都会存储在/var/spool/cron/目录里# 查看当前服务状态service crond status# 操作服务/sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置# 查看开机启动服务ntsysv # 退出时, 按tab切换# 加入开机自动启动chkconfig –level 35 crond on 配置说明 123456789101112131415161718# 基本格式 : * * * * * command 分 时 日 月 周 命令 # 每个小时的第几分钟执行该任务. 其它的类似第1列表示分钟1～59 每分钟用*或者 */1表示 第2列表示小时0～23（0表示0点） 7-9表示：8点到10点之间第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令# 记住几个特殊符号的含义:“*”代表取值范围内的数字,“/”代表”每”,“-”代表从某个数字到某个数字,“,”分开几个离散的数字 配置示例 123456789101112131415161718192021222324252627282930313233# * * * * * command # 分 时 日 月 周 命令 */1 * * * * date &gt;&gt; /root/date.txt上面的例子表示每分钟执行一次date命令可用 tail -f查看30 21 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示每晚的21:30重启apache45 4 1,10,22 * * /usr/local/etc/rc.d/httpd restart上面的例子表示每月1、10、22日的4 : 45重启apache10 1 * * 6,0 /usr/local/etc/rc.d/httpd restart 上面的例子表示每周六、周日的1 : 10重启apache0,30 18-23 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache0 23 * * 6 /usr/local/etc/rc.d/httpd restart上面的例子表示每星期六的11 : 00 pm重启apache* */1 * * * /usr/local/etc/rc.d/httpd restart上面的例子每一小时重启apache* 23-7/1 * * * /usr/local/etc/rc.d/httpd restart上面的例子晚上11点到早上7点之间，每隔一小时重启apache0 11 4 * mon-wed /usr/local/etc/rc.d/httpd restart上面的例子每月的4号与每周一到周三的11点重启apache0 4 1 jan * /usr/local/etc/rc.d/httpd restart 上面的例子一月一号的4点重启apache 更详细的见这里 8. Linux虚拟主机集群测试环境基本搭建1. 第一台虚拟主机的静态ip配置(针对于mac环境) 执行ifconfig命令, 如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667shixuanji@x:~|⇒ ifconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&lt;PERFORMNUD,DAD&gt;gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280stf0: flags=0&lt;&gt; mtu 1280EHC29: flags=0&lt;&gt; mtu 0EHC26: flags=0&lt;&gt; mtu 0XHC20: flags=0&lt;&gt; mtu 0en0: flags=8823&lt;UP,BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500 ether 60:03:08:a1:ac:ee nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect (&lt;unknown type&gt;) status: inactivep2p0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 2304 ether 02:03:08:a1:ac:ee media: autoselect status: inactiveawdl0: flags=8902&lt;BROADCAST,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484 ether 72:25:b2:c8:2a:03 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: inactiveen1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 32:00:1a:0d:12:00 media: autoselect &lt;full-duplex&gt; status: inactiveen2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 32:00:1a:0d:12:01 media: autoselect &lt;full-duplex&gt; status: inactivebridge0: flags=8822&lt;BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500 options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt; ether 32:00:1a:0d:12:00 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x2 member: en1 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 10 priority 0 path cost 0 member: en2 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 11 priority 0 path cost 0 media: &lt;unknown type&gt; status: inactiveutun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000 inet6 fe80::2ed8:c28:27b2:f5d2%utun0 prefixlen 64 scopeid 0xd nd6 options=201&lt;PERFORMNUD,DAD&gt;vmnet1: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:01 inet 172.16.63.1 netmask 0xffffff00 broadcast 172.16.63.255vmnet8: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:08 inet 192.168.170.1 netmask 0xffffff00 broadcast 192.168.170.255en4: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=3&lt;RXCSUM,TXCSUM&gt; ether 00:0e:c6:cc:ae:d7 inet6 fe80::1c60:7fe2:3947:4ec0%en4 prefixlen 64 secured scopeid 0x11 inet 192.168.63.148 netmask 0xffffff00 broadcast 192.168.63.255 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect (100baseTX &lt;full-duplex,flow-control&gt;) status: active 找到最后的vmnet8, 其中的 inet 就是虚拟主机的网段, 配置虚拟主机的静态ip的时候, 就配置此网段内的. 广播地址 broadcast也是虚拟主机NAT的广播地址, 配置时可以不填 123vmnet8: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:08 inet 192.168.170.1 netmask 0xffffff00 broadcast 192.168.170.255 修改虚拟机网卡配置vi /etc/sysconfig/network-scripts/ifcfg-eth, 做如下配置 123456789101112DEVICE=eth0HWADDR=00:0C:29:D6:C7:0ETYPE=EthernetUUID=bebc1b63-4f20-405a-860a-32d0d8211582ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=static # ip类型IPADDR=192.168.170.6 # ip地址, 与 vmnet8 在同一网段NETMASK=255.255.255.0 # 子网掩码GATEWAY=192.168.170.2 # 网关, 跟 ip在同一网段DNS1=192.168.170.2 # 与 ip 同一网段 DNS2=8.8.8.8 # google的 dns 重启网络服务 service network restart 2. 复制原本的虚拟主机 复制虚拟主机1到2 按照原虚拟主机的root用户名&amp;密码登录2 3. 修改新机网卡 修改网卡vi /etc/udev/rules.d/70-persistent-net.rules, 删除eth0所在的整个段落, 把下面的eth1改为eth0, 保存退出 修改网卡配置vi /etc/sysconfig/network-scripts/ifcfg-eth0, 如果有UUID, HARDDR, 删掉, IPADDR改为与原虚拟主机不同的地址, 但要在同一网段, BOOTPROTO改为static4. 修改新机hostname ​ 修改hostname, /etc/sysconfig/network, 把HOSTNAME改为要修改的名字 5. 免密登录 新机生成自己公钥 ssh-kepygen, 注意: 如果原本主机中已经生成, 此处在提示verwrite (y/n)?的时候要选择y, 才会重新生成覆盖 把新主机公钥发送给其它机器 ssh-copy-id root@xxx(其它主机ip), 此命令相当于 下面2条命令的效果 12cat id_rsa.pub &gt; authorized_keysscp -r authorized_keys root@192.168.123.202:/root/.ssh/ 其他主机也把公钥发给新主机, 此时就可以实现主机间的免密登录了. 6. 功能增强(可选) 可以在 每台机器中设置host别名, vi /etc/hosts, 加上xxx.xxx.xx.xxx cts1/2/3..., 这样在访问其他主机时, 可以直接用别名替代域名 如果是用的zsh的shell, 可以在所有主机的 ~.zshrc中, 添加alias login1=&#39;ssh root@cts1&#39; &gt;&gt; ~/.zshrc, 这样可以直接 用 login1登录到对应的主机. 9. 安装, 使用 zsh &amp; oh-my-zsh &amp;相关插件主骨架安装&amp;介绍 安装zsh套件 1yum install zsh -y 安装 oh-my-zsh套件 1sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" zsh 的一些基本配置操作, 常用插件安装见这里! 1234567891011121314151617181920# 查看oh-my-zsh 的主题ls ~/.oh-my-zsh/themes# 可以更改为random, 这样会随机显示, 很有乐趣, 直接输入zsh也会切换vi ~/.zshrcZSH_THEME="random"# 添加plugin, 按照对应方式安装plugins=(git ... ... )# 设置zsh为默认的shellchsh -s /bin/zsh# 添加alias 到 ~/.zshrcalias vi='vim'alias zshconfig='vi ~/.zshrc'alias vimconfig='vi ~/.vimrc'# 卸载 oh-my-zshuninstall_oh_my_zsh zsh zsh 的一些骚气操作 12345671. 兼容 bash, 这个就不用说了2. 输入某条命令, 比如 cat, 然后用上下键, 可以翻阅所有执行过的命令3. 各种补全, 输入任何命令, 按 2下 tab键, 下面会出现所有可能的补全, 可以 tab, 或 上下左右切换.4. 比如要杀掉进程java, 原来是需要 ps aux | grep java, 查进程的 PID，然后 kill PID; 现在只需要 kill java, 然后按下 tab, java会被替换为 对应的 PID, 点回车, kill !5. 目录浏览和跳转, 输入 d, 可以列出在这个回话中访问过的目录列表, 再输入列表前的序号, 即可直接跳转.6. 在当前目录下输入 .. 或 ... , 或者直接输入目录名, 都可以直接跳转, 甚至都不需要使用 cd命令了.7. 通配符搜索：ls -l */.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了. zsh主题介绍, zsh插件介绍 zsh常用插件安装安装 zsh-autosuggestions12345678910111213141516171819方式1: # 下载到本地git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions# 添加到.zshrc, 这样就不用每次source了添加 source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 到 .zshrc 尾部plugins=() 中添加上 zsh-autosuggestions, 用空格隔开即可======================方式2: 官方建议# 少了添加source到 ~/.zshrc这一步, 猜想是会按照默认的路径加载? # 1.Clone this repository into $ZSH_CUSTOM/plugins (by default ~/.oh-my-zsh/custom/plugins)git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions# 2.Add the plugin to the list of plugins for Oh My Zsh to load:plugins=(zsh-autosuggestions)# 3.Start a new terminal session. #####安装 autojump 1234567891011# 下载到本地git clone git://github.com/joelthelion/autojump.git# 执行安装脚本cd autojump./install.py# 安装完成在~/下面有.autojump目录, 在.zshrc中加一句[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh# 接下来可以愉悦的使用 j 了 安装 zsh-syntax-highlighting 12345678# 到 ~/.zshrc 目录, 克隆仓库git clone https://github.com/zsh-users/zsh-syntax-highlighting.git# source the script 到 ~/.zshrcecho "source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc# 在当前 shell生效source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
