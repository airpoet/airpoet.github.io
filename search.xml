<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习笔记-4]]></title>
    <url>%2F2018%2F05%2F28%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[1、Linux shell简介1.1、Shell概述Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。 Shell既是一种命令语言，又是一种程序设计语言： 作为命令语言，它交互式地解释和执行用户输入的命令； 作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。 Shell它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。Shell是用户与内核进行交互操作的一种接口，目前最流行的Shell称为bash Shell（Bourne Again Shell） Shell是一门编程语言(解释型的编程语言)，即shell脚本(就是在用linux的shell命令编程)，Shell脚本程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行 Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本 Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器，可以通过cat /etc/shells命令查看系统中安装的shell，不同的shell可能支持的命令语法是不相同的 sh是Unix 标准默认的shell，由Steve Bourne开发，是Bourne Shell的缩写。 bash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是Bourne Again Shell的缩写。 Shell本身支持的命令并不多，内部命令一共有40个，但是它可以调用其他的程序，每个程序就是一个命令，这使得Shell命令的数量可以无限扩展，其结果就是Shell的功能非常强大，完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。 1.2、Shell基本格式代码写在普通文本文件中，通常以.sh结尾，虽然不是强制要求，但希望大家最好这么做 12345vi helloworld.sh--------------------------#!/bin/bash ## 表示用哪一种shell解析器来解析执行我们的这个脚本程序，这句话只对自执行有效，对于使用sh helloworld.sh无效echo "hello world" ## 注释也可以写在这里 在这里，我们就写好了一个shell脚本，第一行是固定需要的，表明用哪一种shell解析器来执行我们的这个脚本程序。本质上，shell脚本里面的代码都是就是一些流程控制语句加一些特殊语法再加shell**命令**组成。其中，我们可以当做每一个命令就是shell编程当中的关键字。 1.3、Shell执行方式1 、sh 方式或者bash 方式 sh helloworld.sh bash helloworld.sh ## 直接指定用系统默认的bash shell解释执行 2 、source 方式或者. 方式 source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。 功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句 source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。 用法： . helloworld.sh source helloworld.sh 3 、直接执行该脚本文件 可以有两种方式，不过这两种方式的执行，都需要该文件有执行权限 所以在执行之前，我们要更改他的执行权限 1、 切换到该文件所在的路径然后执行命令： ./helloworld.sh 2、 直接以绝对路径方式执行 /home/linux/hellworld.sh 1.4、Shell注释单行注释：Shell脚本中以#开头的代码就是注释 # xxx 多行注释：Shell脚本中也可以使用多行注释：:&lt;&lt;! xxx ! 2、Shell基本语法2.1、变量2.1.1、系统变量Linux Shell中的变量分为“系统变量”和“用户自定义变量” 系统变量可以通过set命令查看，用户环境变量可以通过env查看： 常用系统变量：\$PWD \$SHELL \$USER $HOME 2.1.2、自定义变量12345678910111213141516171819# 1.注意, 变量中间不能有空格A=123 echo $A# 2.变量中间有空格的话要加引号 - 双引号中间可以引用变量 a=zs b="this is $a" echo $b this is zs - 单引号引用变量会原样输出 b='this is $a' echo $b this is $a # 3. 要在变量后直接连接字符, 要用&#123;&#125;把变量括起来 $&#123;变量名&#125;其它字符 echo $&#123;A&#125;ddd helloddd 2.1.3、变量高级用法 撤销变量：unset ABC 声明静态变量：readonly ABC= ‘abc’ 特点是这种变量是只读的，不能unset 在一个 .sh 中. 以绝对路径的形式调另一个 .sh 使用export关键字 export A=”A in a.sh” 意味着把变量提升为当前shell 进程中的全局环境变量，可供其他子shell 程序使用， A 变量就成了a.sh 脚本所在bash 进程的全局变量，该进程的所有子进程都能访问到变量A 通过 . /root/bin/b.sh 或 source /root/bin/b.sh 来调用 总结： a.sh中直接调用b.sh，会让b.sh在A所在的bash进程的“子进程”空间中执行 而子进程空间只能访问父进程中用export定义的变量 一个shell进程无法将自己定义的变量提升到父进程空间中去 source或者“.”号执行脚本时，会让脚本在调用者所在的shell进程空间中执行 2.1.4、反引号赋值 a=`ls -l /root/bin` ##反引号，运行里面的命令，并把结果返回给变量a 另外一种写法： a=$(ls -l /root/bin) 2.1.5、变量有用技巧 形式 说明 ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值 ${var:+word} 如果变量 var 被定义，那么返回word，但不改变 var 的值 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。 若此替换出现在Shell脚本中，那么脚本将停止运行 2.1.6特殊变量 $? 表示上一个命令退出的状态码 $$ 表示当前进程编号 $0 表示当前脚本名称 $n 表示n 位置的输入参数（n**代表数字，n&gt;=1 ）** $# 表示参数的个数，常用于循环 $* 和$@ 都表示参数列表 注意：$*与$@区别 $* 和 $@ 都表示传递给函数或脚本的所有参数** 不被双引号” “包含时 $* 和 $@ 都以\$1 \$2 … \$n 的形式组成参数列表 当它们被双引号” “包含时 “$*“ 会将所有的参数作为一个整体，以”\$1 \$2 … \$n”的形式组成一个整串； $* 会将各个参数分开，以”\$1” “\$2” … “\$n” 的形式组成一个参数列表 2.1.7 变量的其他注意点 使用变量 使用一个定义过的变量, 只需要在变量名前面加 $ 符号 如果变量后面直接跟上了字符串, 就必须要加花括号 推荐给所有变量加上花括号, 这个是好的编程习惯 已定义的非只读变量, 可以被重新定义 2.2、运算符2.2.1、算数运算符]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-2]]></title>
    <url>%2F2018%2F05%2F27%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[1.. VI文本编辑器学会使用vi编辑器是学习Linux系统的必备技术之一，因为一般的Linux服务器是没有GUI界面的，Linux运维及开发人员基本上都是通过命令行的方式进行文本编辑或程序编写的。vi编辑器是Linux内置的文本编辑器，几乎所有的类unix系统中都内置了vi编辑器，而其它编辑器则不一定，另外很多软件会调用vi编辑进行内容编写，例如crontab定时任务。较之于其它编辑器或GUI编辑器，vi编辑速度是最快的。VIM是它的增强版本，VI有三种基本工作模式，分别是： 命令模式（command mode）、或者叫一般模式 插入模式（insert mode）、或者叫编辑模式 底行模式（last line mode）、或者叫命令行模式 1. 最基本用法 1、首先会进入“一般模式”，此模式只接受各种命令快捷键，不能编辑文件内容 2、按i键，就会从一般模式进入编辑模式，此模式下，敲入的都是文件内容 3、编辑完成之后，按Esc键退出编辑模式，回到一般模式 4、再按：，进入“底行命令模式”，输入wq命令，回车即可保存退出 2. 移动光标 (一般模式) 1、 使用上下左右键可以移动光标 2、 使用h,j,k,l，依次是向左，下，上，右移动 3、 w：将光标移动到下一个单词的首字母处 4、 W：利用空格向后移动光标，就是忽略标点 5、 b：利用word包括标点向前移动光标, 与w相对应 6、 B：利用空格向前移动光标，忽略标点 7、 e：将光标移动到下一个word的尾部，包括符号 8、 E: 将光标移动到下一个空格分隔字的尾部 9、 (：移动到句子开始 10、 )：移动到句子结束 11、 0：移动光标到本句句首 12、 $：移动光标到本行行尾 13、 {：移动到段落开始 14、 }：移动到段落结束 15、 H：屏幕顶端 16、 L：屏幕底端 17、 M：移动到屏幕中央位置 18、 gg：直接跳到文件的首行行首 19、 G：直接跳到文件的末行行首 20、 最强光标移动： % : 匹配括号移动，包括(, {, [.（你需要把光标先移到括号上） *: 匹配光标当前所在的单词，移动光标到下一个匹配单词 #: 匹配光标当前所在的单词，移动光标到上一个匹配单词 重点总结: h l : 左右, j k : 下上. w: 下一个单词 , b: 上一个单词. 0: 本行行首, $: 本行行尾 (: 句子开始, ): 句子结束 {: 段落开始 }: 段落结束 gg: 文件行首 G: 文件行尾 %: 下一个括号 *: 下一个单词 #: 上一个单词 3. 常用操作(一般模式 &gt;&gt; 插入模式) 单位 指令1 指令2 当前位 前一位/后一位 i: 在光标前一位开始插入 a: 光标后一位开始插入 当前行 最前/最后 I: 在该行的最前面插入 A: 在该行的最后插入 当前行 上一行/下一行 o: 小o, 当前行的下一行插入空行 O: 大o, 当前内容下移一行, 当前行插入空行 当前行 删除 dd: 删除当前行 3dd: ndd, 删除从当前行开始的 n行 当前行 复制 yy: 复制光标所在行 3yy: 复制从当前行开始的3行 粘贴 p: 粘贴到光标所在行的下一行 撤销 u: undo 撤销操作, 可一直撤销到最前面 重点总结: i : 当前光标前开始插入; a: 光标后一位开始插入 I: 在该行的最前面插入; A: 在该行的最后插入 o: 小o, 当前行的下一行插入空行 O: 大o, 当前内容下移一行, 当前行插入空行 dd: 删除当前行 3dd: ndd, 删除从当前行开始的 n行 yy: 复制光标所在行 3yy: 复制从当前行开始的3行 p: 粘贴到光标所在行的下一行 u: undo 撤销操作, 可一直撤销到最前面 4. 查找并替换 在底行命令模式中输入 1. 显示行号 :set nu 2. 隐藏行号 :set nonu 3 .查找关键字 :/you ## 效果：查找文件中出现的you，并定位到第一个找到的地方，按 n可以定位到下一个匹配位置（按N定位到上一个） 查询的时候被匹配上的字符串会被高亮，可以在命令模式下使用:noh取消高亮 4. 直接跳转到 3行 : 3 5. 替换操作 :1 s/sad/bbb 将第一行的第一个sad替换为bbb :1,5 s/sad/bbb 将第一行到第五行的第一个sad替换为bbb :1,. s/sad/bbb 将第一行到光标行的第一个sad替换为bbb :.,$ s/sad/bbb 将光标行到缓冲区最后一行的sad替换为bbb :s/sad/bbb 查找光标所在行的第一个sad，替换为bbb :s/sad/bbb/g 查找光标所在行的所有sad，替换为bbb :%s/sad/bbb 查找文件中所有行第一次出现的sad，替换为bbb :%s/sad/bbb/g 查找文件中所有的sad，替换为bbb 6. 屏幕翻滚类命令 Ctrl + u：向文件首翻半屏 Ctrl + d：向文件尾翻半屏 Ctrl + f：向文件尾翻一屏 Ctrl＋b：向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部 7. 其它的小技巧 r 替换光标处一个字符 R 进入替换模式，从光标处连续替换 s 删除当前字符，进入插入模式 S 删除当前行，进入插入模式 ≈ dd, dd也会删除当前行, 但是不会进入插入模式 f s 光标行内向后查找第一个出现的字符s (先输f , 再输 s, 向后找 s) F s 光标行内向前查找第一个出现的字符s (先输F , 再输 s, 向前找 s) ~ 大小写转换，只转换光标处字符 8. 速查网址 vim详解 2.. 网络管理ifconfig命令ifconfig命令主要用于配置网络接口，如果不加任何参数，则ifconfig命令用于查看当前所有活动网络接口的状态信息，如下图： eth0 表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:0C:29:D6:C7:0E。 inet addr 用来表示网卡的IP地址，此网卡的IP地址是192.168.179.6，广播地址192.168.170.255，掩码地址Mask:255.255.255.0。 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回坏地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。 ifconfig其他常用使用 -a 显示所有网络接口，包括停用的 -s 短格式显示网络信息，同netstat -i -v 显示详细信息，在网络出错的情况下适用 interface 指定网络接口 up 启用网络接口 down 关闭网络接口 启动关闭指定网卡&amp; 常用操作： 12345ifconfig eth0 up #启动网卡ifconfig eth0 down #关闭网卡 ifconfig #处于激活状态的网络接口ifconfig -a #所有配置的网络接口，不论其是否激活ifconfig eth0 #显示eth0的网卡信息 网络配置1. 三种通信模式Vmware中的虚拟机和宿主机进行通信有三种网络方式，它们分别是： Bridged （桥接模式） NAT （网络地址转换模式） Host-Only （仅主机模式） Bridged （桥接模式） 桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致 Host-Only （仅主机模式）宿主 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 NAT 模式 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。 2. NAT网络模式的配置见Linux学习笔记3, 第8条: Linux虚拟主机集群测试环境基本搭建 3. 其它的常用网络管理命令 ping命令: 常用来测试网络连接是否正常 先确定能ping通 ping www.baidu.com host命令: host命令用来进行DNS查询 然后用host命令可以查看到 host www.baidu.com 然后通过浏览器访问该地址：119.75.213.61 netstat命令: netstat命令可以显示网络接口的很多统计信息，包括打开的socket和路由表 以下是常用命令选项 123456789101112-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令 例子 1、列出所有端口，包括监听和未监听的：netstat -a 2、列出所有TCP端口：netstat -at 3、列出所有UDP端口：netstat -au 4、列出所有监听状态的TCP端口：该命令最重要用来查看哪个程序占用了哪个网络端口号 123# 比如查看谁占用了 tcp 的80 端口netstat -nltp | grep 80 [23:04:54]tcp 0 0 :::80 :::* LISTEN 3890/httpd 4. 防火墙防火墙根据配置文件/etc/sysconfig/iptables来控制本机的“出、入”网络访问行为 其对行为的配置策略有四个策略表 基础必备技能 | 查看防火墙状态 | service iptables status || ———————- | ————————– || 开启防火墙 | service iptables start || 关闭防火墙 | service iptables stop || 关闭防火墙开机自启 | chkconfig iptables off || 设置防火墙开机自启 | chkconfig iptables on | 扩展知识 1234567891011121314151617181920212223242526# 1、列出iptables规则iptables -L -n# 列出iptables规则并显示规则编号iptables -L -n --line-numbers# 2、列出iptables nat表规则（默认是filter表）iptables -L -n -t nat# 3、清除默认规则（注意默认是filter表，如果对nat表操作要加-t nat）#清除所有规则iptables -F#重启iptables发现规则依然存在，因为没有保存service iptables restart#保存配置service iptables save# 4、禁止SSH登陆（如果服务器在机房，一定要小心）iptables -A INPUT -p tcp --dport 22 -j DROP# 5、删除规则iptables -D INPUT -p tcp --dport 22 -j DROP # 6、加入一条INPUT规则开放80端口 iptables -I INPUT -p tcp --dport 80 -j ACCEPT 3. Linux系统启动级别管理使用runlevel命令可以查看系统运行的级别 12runlevel [23:12:37]N 3 修改系统默认启动级别 1234567891011121314# 启动级别在这个路径查看vi /etc/inittab-------------------# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault: id:3:initdefault: ## 配置默认启动级别 ## 通常将默认启动级别设置为：3 4. 用户和组1. 用户和组的概念Linux是一个多任务多用户的操作系统，当我们在使用ls -l命令的时候我们看到如下信息： 123drwxrwxr-x. 2 root root 4096 5月 24 00:15 test-rw-r--r--. 1 root root 58 5月 25 11:00 test.sh-rwxr-xr-x. 1 root root 35 5月 23 23:55 test.txt test：表示文件或者目录，具体的文件类型是由该行最前面的那个符号表示 12345- 当为[ *d* ]则是目录- 当为[ *-* ]则是文件；- 若是[ *l* ]则表示为链接文档(link file)；- 若是[ *b* ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；- 若是[ *c* ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置); drwxrwxr-x ：该文件的类型和权限信息 2 ：链接数，如果是文件则是1 ， 如果是文件夹则表示该文件夹下的子文件夹个数 第一个root ：文件或者目录的所属者** 第二个root ：所属用户组** 4096 ：文件或者目录的大小，是目录的话一般都是4096 5月 24 00:15：文件的最后编辑时间 通过以上信息得知，每个文件都设计到用户和组的权限问题 在Linux中，用户是能够获取系统资源的权限的集合，组是权限的容器 Linux 用户类型 用户类型 描述 管理员root 具有使用系统所有权限的用户,其UID 为0 系统用户 保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间 普通用户 即一般用户,其使用系统的权限受限,其UID为500-60000之间. 与Linux用户信息相关的文件有两个：分别是/etc/passwd和 /etc/shadow 123456789101112# 查看文件/etc/passwd文件的内容，选取第一行：root:x:0:0:root:/root:/bin/bashroot:用户名x:密码占位符，密码保存在shadow文件内0:用户id，UID0:组id，GIDroot:注释信息/root:用户家目录/bin/bash:用户默认使用shell登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 Linux用户组类型 用户组类型 描述 系统组 一般加入一些系统用户 普通用户组 可以加入多个用户 私有组/基本组 当创建用户时,如果没有为其指明所属组，则就为其定义一个私有的用户组，起名称与用户名同名，当把其他用户加入到该组中，则其就变成了普通组 与Linux用户组信息相关的文件有两个：分别是/etc/group和 /etc/gshadow 12345# 查看文件/etc/group文件内容，选取一个普通组行：hadoop:x:500:hadoop:组名x:组密码占位符500:组id 2. 用户操作Linux中的用户管理主要涉及到用户账号的添加、删除和修改。所有操作都影响/etc/passwd中的文件内容 添加用户 useradd spark usermod -G bigdata spark ## 设置组 usermod -c “mylove spark” spark ## 添加备注信息 一步完成：useradd -G bigdata -c “mylove” spark 设置密码 passwd spark 根据提示设置密码即可 修改用户 修改spark登录名：usermod -l spark storm 将spark添加到bigdata和root组：usermod -G root,bigdata spark 查看spark的组信息：groups spark 删除用户 userdel -r spark 加一个-r就表示把用户及用户的主目录都删除 3. 组操作前面我们知道，组是权限的集合。在linux系统中，每个用户都有一个用户组，没有指定时都默认为私有组，私有组名同用户名一致，建立用户组的好处是系统能对一个用户组中的所有用户的操作权限进行集中管理。组管理涉及组的添加、删除和修改。组的增加、删除和修改实际上就对/etc/group文件的更新 添加一个叫bigdata的组 groupadd bigdata 查看系统当前有那些组 cat /etc/group 将hadoop用户添加到bigdata组中 usermod -G bigdata spark 或者 gpasswd -a spark bigdata 这两个命令的区分记忆技巧： 命令是什么，就证明对什么做操作，所以最后的参数就是命令的操作对象，中间的可选项表示要干嘛 将spark用户从bigdata组删除 gpasswd -d spark bigdata 将bigdata组名修改为bigspark groupmod -n bigspark bigdata 删除组 groupdel bigdata 4. 为用户配置sudoer权限普通情况下，使用普通用户进行一些简单的操作就OK，但是普通用户和root用户的区别就在于root用户能对系统做任何事，但是普通用户就不行。处处受限。那么假如在某些情况下，普通用户想拥有更大的权限做更多的事情，虽然有权限限制，但也不是不可以。部分操作还是可以赋予更高的权限让普通用户做一次。这就需要给普通用户配置root权限了。意思就是让普通用户使用root权限去做一些操作，这当然是需要配置的。 用root编辑 vi /etc/sudoers 在文件的如下位置，为hadoop添加一行即可 root ALL=(ALL) ALL hadoop ALL=(ALL) ALL spark ALL=(ALL) ALL 然后，hadoop用户和spark用户就可以用sudo来执行系统级别的指令 [hadoop\@hadoop01 ~]\$ sudo useradd huangxiaoming 5. 切换用户在linux的系统使用过程当中，免不了会有多个用户来回切换使用。 所以在此提供切换用户的使用操作：切换用户使用的命令是 su（switch user） 从普通用户切换到root用户 , 需要输密码 su root 或 su 从root用户切换到普通用户, 不需要输密码 su xxx 5. 文件权限1、linux文件权限的描述格式解读Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內 linux文件的用户权限的分析图 123456 -rw-r--r-- 1 user staff 651 Oct 12 12:53 .gitmodules# ↑╰┬╯╰┬╯╰┬╯# ┆ ┆ ┆ ╰┈ 0 其他人# ┆ ┆ ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ g 属组# ┆ ╰┈┈┈┈ u 属主# ╰┈┈ 第一个字母 `d` 代表目录，`-` 代表普通文件 d：标识节点类型（d：文件夹 -：文件 l：链接） r：可读 w：可写 x：可执行 文件 文件夹 r 可读取内容 可以ls w 可修改文件的内容 可以在其中创建或者删除子节点 x 能否运行这个文件 能否cd**进入这个目录** 2、 修改文件权限chmod命令 用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 语法12345chmod(选项)(参数)r=读取属性 //值＝4 w=写入属性 //值＝2 x=执行属性 //值＝1 选项： u User，即文件或目录的拥有者；g Group，即文件或目录的所属群组；o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a All，即全部的用户，包含拥有者，所属群组以及其他用户；r 读取权限，数字代号为“4”;w 写入权限，数字代号为“2”；x 执行或切换权限，数字代号为“1”；- 不具任何权限，数字代号为“0”；s 特殊功能说明：变更文件或目录的权限。 参数: 权限模式：指定文件的权限模式；文件：要改变权限的文件。 示例修改文件权限 1234567891011# 直接修改chmod g-rw haha.dat ## 表示将haha.dat对所属组的rw权限取消chmod o-rw haha.dat ## 表示将haha.dat对其他人的rw权限取消chmod u+x haha.dat ## 表示将haha.dat对所属用户的权限增加xchmod a-x haha.dat ## 表示将haha.dat对所用户取消x权限# 也可以用数字的方式来修改权限(常用)chmod 664 haha.dat就会修改成 rw-rw-r--如果要将一个文件夹的所有内容权限统一修改，则可以-R参数chmod -R 770 aaa/ 修改文件所有权 1234# &lt;只有root权限能执行&gt;chown angela aaa ## 改变所属用户chown :angela aaa ## 改变所属组chown angela:angela aaa/ ## 同时修改所属用户和所属组 6. 压缩打包gzipgzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。 gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。 语法 gzip (选项) (参数) 选项 123456789101112131415161718-a或——ascii：使用ASCII文字模式；-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；-N或——name：压缩文件时，保存原来的文件名称及时间戳记；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；--best：此参数的效果和指定“-9”参数相同；--fast：此参数的效果和指定“-1”参数相同。-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。 参数 文件列表：指定要压缩的文件列表。 示例 12345678910111213# 把test6目录下的每个文件压缩成.gz文件gzip *# 把上例中每个压缩的文件解压，并列出详细的信息gzip -dv *# 详细显示例1中每个压缩的文件的信息，并不解压gzip -l *# 压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gzgzip -r log.tar# 递归的压缩目录gzip -rv test6# 这样，所有test下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。# 递归地解压目录gzip -dr test6 bzipbzip2命令 用于创建和管理（包括解压缩）“.bz2”格式的压缩包。 语法 bzip2 (选项) (参数) 选项 123456789101112-c或——stdout：将压缩与解压缩的结果送到标准输出；-d或——decompress：执行解压缩；-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；-h或——help：在线帮助；-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；-s或——small：降低程序执行时内存的使用量；-t或——test：测试.bz2压缩文件的完整性；-v或——verbose：压缩或解压缩文件时，显示详细的信息；-z或——compress：强制执行压缩；-V或——version：显示版本信息；--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。 参数 文件：指定要压缩的文件。 示例 1234567891011## 压缩指定文件filename:bzip2 filename 或 bzip2 -z filename## 解压指定的文件filename.bz2:bzip2 -d filename.bz2 或 bunzip2 filename.bz2# 压缩解压的时候将结果也输出：bzip2 -v filename filename: 0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.# 压缩解压的时候，除了生成结果文件，将原来的文件也保存: bzip2 -k filename# 解压到标准输出, 输出文件的内容bzip2 -dc filename.bz2 tarLinux下的归档使用工具，用来打包和备份。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 其实最简单的使用 tar 就只要记忆底下的方式即可： tar.gz 格式: 1234# 一次性打包并压缩、解压并解包打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]解压并解包： tar -zxvf [原文件名].tar.gz注：z代表用gzip算法来压缩/解压。 tar.bz2格式: 1234# 一次性打包并压缩、解压并解包打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]解压并解包： tar -jxvf [原文件名].tar.bz2注：小写j代表用bzip2算法来压缩/解压。 其实用不到的话就不用看了, 下面的. 语法 tar(选项)(参数) 选项 1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 参数 文件或目录：指定要打包的文件或目录列表。 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 12345- z：有gzip属性的- j：有bz2属性的- Z：有compress属性的- v：显示所有过程- O：将文件解开到标准输出 实例 zip格式 123压缩： zip -r [目标文件名].zip [原文件/目录名]解压： unzip [原文件名].zip注： -r参数代表递归 tar格式（该格式仅仅打包，不压缩） 123打包：tar -cvf [目标文件名].tar [原文件名/目录名]解包：tar -xvf [原文件名].tar注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。 tar.gz格式(方式二常用) 12345678# 方式一：利用前面已经打包好的tar文件，直接用压缩命令。压缩：gzip [原文件名].tar解压：gunzip [原文件名].tar.gz# 方式二：一次性打包并压缩、解压并解包打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]解压并解包： tar -zxvf [原文件名].tar.gz注：z代表用gzip算法来压缩/解压。 tar.bz2格式 12345678方式一：利用已经打包好的tar文件，直接执行压缩命令：压缩：bzip2 [原文件名].tar解压：bunzip2 [原文件名].tar.bz2方式二：一次性打包并压缩、解压并解包打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]解压并解包： tar -jxvf [原文件名].tar.bz2注：小写j代表用bzip2算法来压缩/解压。 jar格式 12345678910压缩：jar -cvf [目标文件名].jar [原文件名/目录名]解压：jar -xvf [原文件名].jar# 注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：Manifest-Version: 1.0Created-By: 1.6.0_27 (Sun Microsystems Inc.)Main-class: the_name_of_the_main_class_should_be_put_here# 然后用如下命令打包：jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名] 这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static void main方法了。 7z格式 12345压缩：7z a [目标文件名].7z [原文件名/目录名]解压：7z x [原文件名].7z注：这个7z解压命令支持rar格式，即：7z x [原文件名].rar 其它例子 参考网址 7. Linux开关机和重启 开机：开机键 关机：shutdown，halt，init 0，poweroff 重启：reboot，init 6 Shutdown命令详解： shutdown -h now ## 立刻关机 shutdown -h +10 ## 10分钟以后关机 shutdown -h 12:00:00 ##12点整的时候关机]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-1]]></title>
    <url>%2F2018%2F05%2F26%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[1&gt; 初识Linux1. Linux介绍Linux系统是一套免费使用和自由传播的类UNIX操作系统（主要用在服务器上），是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了UNIX以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 UNIX：操作系统，是美国AT&amp;T公司贝尔实验室于1969年完成的操作系统，最早由肯·汤普逊（Ken Thompson），丹尼斯·里奇（Dennis Ritchie）开发。在1971年首次对外发布，刚好在1971，丹尼斯·里奇（Dennis Ritchie）发明了C语言，后来在1973，Unix被他用C语言重新编写。Unix前身源自于MultiCS，叫UniCS，后来改名叫Unix。 POSIX：可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE（电气和电子工程师协会）为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称。 GNU：1983年，Richard Stallman（理查德·马修·斯托曼）创立GNU计划。一套完全自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标（发展出一套完整的开放源代码操作系统来取代Unix），名称来自GNU\’s Not Unix!的递归缩写。 GPL：一种GNU通用公共许可协议，为保证GNU软件可以自由的使用、复制、修改和发布，所有的GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，是一个被广泛使用的自由软件许可协议条款，保证终端用户运行、学习、分享（复制）及编辑软件之自由，GPL是自由软件和开源软件的最流行许可证，特色表现： •取得软件与原始码：您可以根据自己的需求来执行这个自由软件 •复制：您可以自由的复制该软件 •修改：您可以将取得的原始码进行程序修改工作，使之适合您的工作 •再发行：您可以将您修改过的程序，再度的自由发行，而不会与原先的撰写者冲突 •回馈：您应该将您修改过的程序代码回馈于社群 ==不同许可证的区别== 1985年，Richard Stallman又创立了自由软件基金会（Free Software Foundation，FSF）来为GNU计划提供技术、法律以及财政支持。 1990年，GNU计划开发主要项目有Emacs（文本编辑器）、GCC（GUN Compiler Collection，GNU编译器集合）、Bash等，GCC是一套GNU开发的编程语言编译器。还有开发一些UNIX系统的程序库和工具。 Linux操作系统诞生于1991年10月5日（这是第一次正式向外公布时间），与UNIX兼容，并在GPL条款下发布。现在，Linux产生了许多不同的Linux发行版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。 1992年，Linux与其他GUN软件结合，完全自由的GNU/Linux操作系统正式诞生，简称Linux ==Linux的基本思想有两点== 第一，一切都是文件 第二，每个软件都有确定的用途 与Unix思想十分相近。 2. Linux特点1、分时的多用户、多任务操作系统 2、多数网络协议支持、方便的远程管理 3、强大的内存管理和文件系统管理 4、大量的可用的软件和免费的软件 5、优良的稳定性和安全性 6、良好的可移植性和灵活性 7、可供选择的厂商多 3. Linux操作系统架构 补充：linux内核必须加上一个”界面”软件，才能让用户去使用，”界面”分两类： a、命令行界面CLI SHELL（有很多种，最流行的一种是bash shell） b、图形界面GUI SHELL（也有很多种，目前最流行的有两种：gnome和kde） 4. Linux内核严格来讲，Linux不是一个操作系统，Linux只是一个操作系统中的内核。 内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O、进程管理等。 内核官网：[http://www.kernel.org/]{.underline}。目前最新的内核版本：4.13.5 要注意区分linux发型版本和linux内核版本。两者不是同一个事物 下面这位是Linux内核的作者： 这是Linux的logo 5. 常见发行版红帽企业系统（RedHat Enterprise Linux, RHEL） 全球最大的开源技术厂商，全世界内使用最广泛的Linux发布套件， 提供性能与稳定性极强的Linux套件系统并拥有完善的全球技术支持。 官网：[http://www.redhat.com]{.underline} 社区企业操作系统（CentOS） 最初是将红帽企业系统”重新编译/发布”给用户免费使用而广泛使用， 当前已正式加入红帽公司并继续保持免费（随RHEL更新而更新）。 官网：[http://www.centos.org/]{.underline} 红帽用户桌面版（Fedora [Linux]） 最初由红帽公司发起的桌面版系统套件（目前已经不限于桌面版）， 用户可免费体验到最新的技术或工具，而功能成熟后加入到RHEL中。 官网：[http://fedora.redhat.com]{.underline} 国际化组织的开源操作系统（Debian） 提供超过37500种不同的自由软件且拥有很高的认可度， 对于各类内核架构支持性良好，稳定性、安全性强更有免费的技术支持。 官网：[http://www.debian.org/]{.underline} 基于Debian的桌面版（Ubuntu） Ubuntu是一款基于Debian派生的产品，对新款硬件具有极强的兼容能力。 普遍认为Ubuntu与Fedora都是极其出色的LINUX桌面系统。 官网：[http://www.ubuntulinux.org/]{.underline} 当然还有国内的国防科技大学发行麒麟kylin和中科院发行红旗RedFlag 2&gt; Linux文件系统1. CentOS的目录结构 2. 根目录下每个目录的简单解释 /**：**根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中 /bin:/usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等 /boot**：**放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可 /dev**：**存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc**：**系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/gateways、/etc/resolv.conf、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。注：/etc/X11存放与x windows有关的设置 /home**：**系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据 /lib:/lib64:/usr/lib:/usr/local/lib**：**系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /lost+fount**：**系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found /mnt:/media**：**光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载 /opt**：**给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE桌面软件，可以将该软件安装在该目录下。以前的Linux系统中，习惯放置在 /usr/local目录下option /proc**：*此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/等process /root**：**系统管理员root的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 /sbin:/usr/sbin:/usr/local/sbin**：**放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。 /selinux**：**selinux软件目录，用于保证系统安全 /srv**：**服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内service /sys**：**类似于/proc的特殊文件系统，存放内核数据信息 /tmp**：**一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下 /usr**：应用程序存放目录， /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间 usr**：user share resources/unix share resouces /var**：**放置系统执行过程中经常变化的文件，如： /var/log：随时更改的日志文件 /var/log/message：所有的登录文件存放目录 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动 使用建议： 用户应该将文件存储在自己的主目录及其子目录下 系统绝大多数设置都在/etc目录下 不要修改/或者/usr目录下的任何内容，除非你真的清楚你在做什么，也就是说/目录最好和安装好系统之初保持一致 大多数工具和应用软件程序都安装在/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/bin 文件或者目录都有唯一的绝对路径，没有盘符的概念 3&gt; Linux命令终端1. Linux 的命令格式：命令选项 命令参数注意：三者之间要空格隔开，其中命令选项分为长格式和短格式。 短格式用’-‘表示，比如：-l， 长格式用”–”表示，比如：–help， 也可以使用组合格式，比如：-a -l 等价于-la或者-al 2. Linux的默认命令提示符：#：管理员用户 $：普通用户 PS: Linux以回车键表示命令结束，如果 linux命令需要折行输入，那么可以以 \表示每行结束 4&gt; 常用命令归纳分类基本命令 文件管理 mkdir, rmdir, mv, rm, cp, touch, cat, tac, echo, more, less, head, tail, file, find, rename, ln, pwd, scp, alias 磁盘管理 ls, cd, du, df, mount, unmounts, fdisk 文档处理 wc, sort, uniq, cut, sed, awk, grep, vi, diff 用户和组 useradd, usermod, passwd, userdel, groupadd, groupdel, chgrp, su 文件传输 get, put, wget 网络通信 telnet, nc, ifconfig, ping, netstat, ip, host 备份压缩 gzip, bzip2, bunzip2, tar, zip 系统管理 exit, kill, last, ps, top, free, pstree, reboot, halt, shutdown, sudo, who, w, whoami, whereis, which, last, whatis 系统设置 clear, set, unset, hwclock, time, date, 其他 history, hostname, nohup, service, init, rpm, ssh, cal, yum 网站速查http://man.linuxde.net/ http://www.jb51.net/linux/ https://jaywcjlove.github.io/linux-command ps: 直接在命令行中, 用 man xx, 也可以查看命令信息 5&gt; 常用文件系统命令详解磁盘管理 cd change directory 常使用方式： cd sourcedir 进入用户主目录 cd ~ 进入用户主目录 cd - 返回进入此目录之前所在的目录 cd .. 返回上级目录（若当前目录为”/“，则执行完后还在”/“；”..”为上级目录的意思） cd ../.. 返回上两级目录 pwd print working directory pwd 显示当前工作目录 ls list：显示目录内容列表 使用格式：ls 选项 目录或文件名 常用选项 -l：详细信息显示 -a：显示所有子目录和文件的信息，包括隐藏文件 -A：类似于“-a”，但不显示“.”和“..”目录的信息 -R：递归显示内容 -h：以友好方式显示文件大小 例子： ls -l ## 列出文件详细信息， 也可以写作 ll ls -lah ## 以友好方式显示包括隐藏文件的详细信息 du disk usage：显示每个文件和目录的磁盘使用空间 使用格式：du 选项 目录或文件名 常用选项： -a：统计时包括所有的文件，而不仅仅只统计目录 -h：以更易读的字节单位（K、M等）显示信息 -s：只统计每个参数所占用空间总的大小 例子： du -ah ## df disk free：显示磁盘相关信息 常用选项： -h：以更易读的字节单位（K、M等）显示信息 -T：显示分区格式 例子： df -h ## 显示磁盘信息，以友好方式 df -T -h ## 以友好格式显示磁盘信息，并且附加磁盘格式 文件管理 touch 创建空文件 或更新文件时间标记 使用格式： touch 文件名 file 查看文件类型 使用格式： file 文件名 根据文件内容格式判断文件类型。而不是根据后缀名 mkdir 创建文件夹 make directory 使用格式：mkdir 选项 参数 常用选项： -p：已级联的方式创建文件夹 例子： mkdir -p /root/ma/niu/zhu/dagou ## 上级目录不存在自动创建上一级目录，常用 cp 复制文件 使用格式： cp 选项 源文件或目录… 目标文件或目录 常用选项： -r：递归复制整个目录树 -p：保持源文件的属性不变 -i：需要覆盖文件或目录时进行提醒 rm 删除文件或目录 使用格式：rm [选项] 文件或目录 常用选项： -f：强行删除文件或目录，不进行提醒 -i：删除文件或目录时提醒用户确认 -r：递归删除整个目录树 例子： rm -rf /root/ma/ ## 不提醒递归删除整个目录，慎用慎用慎用 mv 移动文件 如果与源文件位置一样，则相当于重命名 使用格式： mv [选项]… 源文件或目录… 目标文件或目录 常用选项： -f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录 -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作 rmdir 删除空文件夹 常用选项： -p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除； rmdir -p /root/aa/bb/cc/dd/ee 删除文件夹ee，如果删除ee后，dd变为空，则删除dd，依次类推 cat 连接文件并打印到标准输出设备上 常用选项： -n或–number：由1开始对所有输出的行数编号 cat /home/hadoop/data.txt ## 查看文件内容 tac 倒序输出文件内容 tac /home/hadoop/data.txt echo 输出指定的字符串或者变量 常用选项： -e：若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： \a 发出警告声； \b 删除前一个字符； \c 最后不加上换行符号； \f 换行但光标仍旧停留在原来的位置； \n 换行且光标移至行首； \r 光标移至行首，但不换行； \t 插入tab； \v 与\f相同； \ 插入\字符； \nnn 插入nnn（八进制）所代表的ASCII字符； 例子： echo ‘ma’ ## 输出ma echo -e ‘ma\n’ ## 打印ma之后换行 echo -ne ‘ma’ ‘zhonghua’ ## 打印完不换行 echo ‘ma’ &gt; ma.dat ## 覆盖 echo ‘ma’ &gt;&gt; ma.dat ## 追加 echo $PWD ## 输出变量内容 head 在屏幕上显示指定文件的开头若干行 默认显示10行 常用选项： -n&lt;数字&gt;：指定显示头部内容的行数； 例子： head -n 5 install.log ## 显示该文件前五行内容 tail 在屏幕上显示指定文件的末尾若干行 常用选项： -f：显示文件最新追加的内容 例子： tail file ## 显示文件file的最后10行 tail +20 file ## 显示文件file的内容，从第20行至文件末尾 tail -c 10 file ## 显示文件file的最后10个字符 tail -f install.log ## 显示最新追加的内容 more 显示文件内容，每次显示一屏 使用方式： 按Space键：显示文本的下一屏内容。 按Enter键：只显示文本的下一行内容。 按h键：显示帮助屏，该屏上有相关的帮助信息。 按b键：显示上一屏内容。 按q键：退出more命令。 less 分屏上下翻页浏览文件内容 和more使用方式基本类似 按e键：向上滚动一行 按y键：向下滚动一行 G：跳到文件末尾 gg：跳到文件首行 ln 用来为文件创件连接 软链接 -s 和 硬链接 ln /mnt/cdrom1 /var/www/html/centos/ —&gt;硬链接 ln -s /mnt/cdrom2 /var/www/html/centos/ –&gt;软链接-符号链接 alias 别名 查看别名：alias 定义别名：alias la=&#39;ll -a 取消别名：unalias la 其它有用的命令123456789101112131415161718man：显示命令帮助信息clear：清屏，或者按ctrl + l也行ctrl + c：退出当前进程ctrl + z：挂起当前前台进程whatis：命令是什么whereis：在标准路径下搜索与名称相关的文件，whereis将所有搜索到的文件都显示which：which在设定的搜索路径下进行目录搜索，只显示搜索到的第一个文件su：切换用户history：显示历史命令hostname：显示主机名set：查看系统变量get：下载文件put：上传文件sudo：以root用户权限执行一次命令exit：退出登录状态w：显示当前连接的用户who：显示当前会话信息uptime：查看系统运行时间 使用小技巧12345678910111213ctrl + u：清除光标前的命令，相当于剪切ctrl + k：清除光标后的命令，相当于剪切ctrl + y：粘贴ctrl + t：把光标前面的那个字符往后挪动一位ctrl + l：清屏!!：执行上一次命令!$：上个命令的最后一个单词ctrl + w：删除光标前一个单词cd data; cat sed.txt：表示先执行cd，然后执行cat，工作目录会切换(cd data; cat sed.txt)：跟上个命令相比，不切换工作目录|：管道符，表示把前面命令内容的输出当做后面命令的输入&gt;：表示内容覆盖&gt;&gt;：表示内容追加]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记-3]]></title>
    <url>%2F2018%2F05%2F25%2FLinux%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[1. 系统服务管理 检查本机httpd服务是否开启, 使用命令service httpd status 开启/关闭/重启 httpd服务 service httpd start/stop/restart 查看所有的服务状态 service --status-all 过滤出某个服务service –status-all | grep httpd` 防火墙服务 sevice iptables status/stop/start/restart 配置后台服务进程开机自启 12345# 开启开机自启http进程-&gt; chkconfig httpd on# 查看httpd的开机自启状态-&gt; chkconfig --list | grep httpdhttpd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 缺省系统运行级别 0 为停机，机器关闭。 1 为单用户模式，就像Win9x下的安全模式类似。 2 为多用户模式，但是没有NFS支持。 3 为完整的多用户模式，是标准的运行级。 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本 电脑的电池用尽时，可以切换到这个模式来做一些设置。 5 就是X11，进到X Window系统了。 6 为重启，运行init 6机器就会重启。 Centos中时区 当前正在使用的时d区文件位于 /etc/localtime 其他时区文件则位于 /usr/share/zoneinfo 中国时区使用 /usr/share/zoneinfo/Asia/Shanghai 更改时区 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果没有 Asia/Shanghai 时区文件，请使用tzselect命令去生成时区文件，生成好的时区文件就在 /usr/share/zoneinfo目录下 修改系统时间 date : 直接查看时间 date -s : 手动设置时间 ntpdate time.windows.www : 同步时间服务器时间 2. 简单磁盘管理 df：列出文件系统的整体磁盘使用量 -h 人性化的列出文件的大小等 123-&gt; # df -h /dev/sr0Filesystem Size Used Avail Use% Mounted on/dev/sr0 3.7G 3.7G 0 100% /media/cdrom du：检查磁盘空间使用量 fdisk：用于磁盘分区 3. 文件的基本属性 - TODO前缀的含义 123456# 查看目录的权限-&gt; # ll -d /var/www/html/localyumdrwxr-xr-x. 7 root root 4096 5月 25 07:50 autojump-rw-r--r--. 1 root root 50434 5月 23 10:11 install.loglrwxrwxrwx. 1 root root 13 5月 25 21:04 localyum -&gt; /media/cdrom/ 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置); r、w、x 对于文件和目录的含义 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以再目录中创建、删除文件 x 执行权限 可以执行文件 可以进入目录 4. 软件安装 TODO1. 二进制发布包安装 TODO:软件已经针对具体平台编译打包发布，只要解压，修改配置即可 安装jdk , 安装tomcat也一样 TODO: 通过 ftp工具把 jdk传到 linux服务器 创建一个 /var/www/html/soft/jdk8 的软链接, 指向服务器中的安装包 —— 这一步失败了 #####2. 源码编译安装 TODO: 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署 安装/卸载 redis 卸载: 首先查看redis-server是否启动 ps aux | grep redis 有的话, 关闭这些进程 kill -9 进程pid 删除redis相应的文件夹就可以了。 find / -name redis 安装: 拷贝到/usr/local, 解压, 删掉原安装包 12tar -zxvf redis-3.0.0.tar.gz rm redis-3.0.0.tar.gz 检查运行环境 123# 检测一下是否可以安装makemake test 安装到指定目录 1make PREFIX=/root/apps/redis install 拷贝配置信息 1cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin 启动 前端模式 bin/redis-server 后端模式启动 修改redis.conf配置文件，daemonize yes` 以后端模式启动 : TODO 3. RPM发布包软件已经按照RedHat（Redhat Package Manager）的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用rpm命令进行安装 Mysql安装 1234567891011121314151617181920# rpm安装命令1、安装包：rpm -ivh 包名参数：-i ：安装的意思-v ：可视化-h ：显示安装进度另外在安装一个rpm包时常用的附带参数有：--force 强制安装，即使覆盖属于其他包的文件也要安装--nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包2、升级包：rpm -Uvh filename-U 升级3、卸载包rpm -e filename （这里的filename是通过rpm的查询功能所查询到的）4、查询一个包是否安装：rpm -q 包名（这里的包名，是不带有平台信息以及后缀名的）5.查询当前安装的所有rpm包：rpm -qa查询当前安装的和sql相关的包：rpm -qa | grep 'sql'查询sqlite安装路径：rpm -ql sqlite 5. 设置本地/网络yum源 首先检查虚拟机的 CD/DVD驱动器是否有挂载iso镜像文件 找到挂载源的位置 在 /dev/sr0下, 将其挂载到/mnt下创建的cdrom文件夹下 mount -t iso9660 -o ro /dev/sr0 /mnt/cdrom 配置开机挂载 , vi /etc/fstab, 增加一行 /dev/cdrom /mnt/cdrom iso9660 defaults 0 0 创建软连接, 设置可以通过web访问 ln -s /mnt/cdrom/ /var/www/html/yumsorurce 修改etc/yum.repos.d中的文件entOS-Media.repo中的enabled=1, 开启从本地寻找, 因为文件中, 原本就配置了baseurl: file:///media/cdrom/, 而我们自己创建了media/cdrom这个目录, 所以就可以从这里面读取了 执行yum repolist, 发现已经能读取出media中的repo了, 大功告成 c6-media CentOS-6 - Media 6,575 tips: 个人觉得还是配置个网络源比较好, 比如163/阿里的. 12345678910111213141516171819# 操作步骤# 1.备份原来的Base源cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo_bak# 2. 下载网易/阿里源 到/etc/yum.repos.d下, 替换掉原本的# 网易源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS6-Base-163.repo# 阿里源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoyum clean allyum makecache# yum使用yum update 􏻦􏻧􏷉􏷊升级系统yum install -y xxx 直接安装, 不用确认􏻈yum update ~ 􏻦􏻧􏸻􏹺􏷜 升级指定软件包yum remove ~ 􏺌􏷎􏸻􏹺􏷜􏷕 卸载指定软件 挂载, 配置源的其他说明 12345678910111213141516171819202122232425# 关于挂载# lrwxrwxrwx. 1 root root 3 5月 25 16:47 cdrom -&gt; sr0cdrom其实是sr0的软链接, 因此直接找sr0即可# 挂载的基本语法mont -t iso9660 -o ro(只读) /dev/sr0 /mnt/cdrom (挂载类型) (挂载方式) (挂载源) (挂载点)# 卸载的语法umount /mnt/cdrom 如果卸载时遇到 umount: /mnt/cdrom: device is busy.解决方式: 1. 查找哪个进程在用: fuser /mnt/cdrom 2. 查找进程: ps -ef | grep 进程号 3. 插死进程: kill -9 进程号, 如果是root用户, 可能会断开连接, 需要重连 4. 然后继续 umount, 如果不行, 就强制卸载 umount -f /mnt/cdrom# 关于etc/yum.repos.d 中文件的说明 CentOS-Base.repo：有网的环境下默认使用这个，这个是第一优先级。因为没网，所以修改文件名，设置成备份文件。这样系统就会使用第二优先级的文件。 CentOS-Media.repo：没网的环境下使用这个，在上图中会发现他默认配置了4个路径，第4个yumsource是我自己加的。意思是说，如果系统检测yum使用了离线安装，那么会从上到下从这4个路径中查找安装软件。所以我们只要把光盘挂载在这四个目录下的任意一个目录即可。同时，该配置文件默认是不启用的，如果想使用需要修改倒数第二行的enabled为1，否则该文件无效。 # /mnt &amp; /media 目录的区别media：挂载一些移动设备，例如光盘，U盘等。mnt： 挂载一些硬盘等设备。所以我们的光盘应该挂载在media目录下，从yum给的默认配置文件也能看出。 6. 进程相关1. ps命令ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。 常用选项包括： 123456ps -1、-a显示所有用户的进程2、-u显示用户名和启动时间3、-x显示所有进程，包括没有控制终端的进程4、-e显示所有进程，包括没有控制终端的进程，较x选项，信息更为简略5、-l显示进程详细信息，按长格式显示 常用组合 ps -au 显示所有用户进程，并给出用户名和启动时间等详细信息 ps -aux 显示所有用户进程，包括没有控制终端的进程，并给出用户和和启动埋单等详细信息 ps -el 按长格式显示进程详细信息 1234567891011121314151617181920212223242526272829303132# 上述命令可能出现的字段含义USER: 进程所有者PID: 进程号PPID: 进程的父进程ID%CPU: CPU占用率C: 进程的CPU占用率%MEM: 内存占用率VSZ: 表示如果一个程序完全驻留在内存的话需要占用多少内存空间;RSS: 指明了当前实际占用了多少内存;TTY: 终端的次要装置号码 (minor device number of tty)F：进程的标志S：进程的状态STAT: 该进程程的状态，有以下值D: 不可中断的静止R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的进程N: 低优先序的进程L: 有记忆体分页分配并锁在记忆体内PRI：进程的优先权NI：进程的Nice值ADDR：进程的地址空间SZ：进程占用内存的大小WCHAN：进程当前是否在运行TTY：进程所属终端START: 进程开始时间TIME: 执行的运行时间COMMAND：所执行的指令CMD：进程的命令 2. kill / pidof / pkill 命令有时候某个进程可能会长期占用CPU资源或无法正常执行或超出运行时间等，此时可能希望人工干预直接将进程杀死，这时候kill命令可以派上用场 12341、kill pid 直接杀死进程，但不能保证一定能杀死2、kill -9 pid 强制杀死进程3、pidof命令用于查看某个进程的进程号（例如：pidof mysqld）4、pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉 3. 进程切换前台进程指的是进程在执行时会将命令行阻塞，直到进程执行完毕；后台进程指的是进程在执行时不会阻塞当前命令行，而是在系统后台执行 123451、ctrl + c 终止进程2、ctrl + z 挂起进程3、fg命令将进程转换到前台执行4、bg命令将进程转换到后台执行5、jobs命令查看任务 4. top命令top 命令可以定期显示所有正在运行和实际运行并且更新到列表中，它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。它也会显示内存和 CPU 使用率过高的正在运行的进程。 按q键退出查看. 5. pstree命令将进程间的关系以树结构的形式展示，能清楚看各进程之间的父子关系 12pstree ：以树状形式显示进程pstree -p ： 以树状形式显示进程，并且显示进程号 6. JPS命令JPS命令是JDK提供的一个检查系统是否启动了JVM进程的一个进程。不是linux系统自带的。主要任务就是用来检查java进程的。 7. 计划任务概念计划任务在Linux的体现主要分为at和crontab，其中： at：通过at命令安排任务在某一时刻执行一次 crontab：通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 命令服务管理crontab在CentOS系统上，crontab服务的名称叫做crond 安装 yum -y install crontabs 服务操作说明 1234567891011service crond start #启动服务service crond stop #关闭服务service crond restart #重启服务service crond reload #重新载入配置service crond status #服务状态#查看crontab服务是否已设置为开机启动，执行命令：chkconfig --list#加入开机自动启动：chkconfig --level 35 crond on crontab功能使用 命令格式 123456789101112131415161718192021222324252627282930313233crontab [-u user] filecrontab [-u user] [ -e | -l | -r ]# crontab 参数说明：-u user：用来设定某个用户的crontab服务，例如，”-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。# 命令示例：crontab file [-u user] ## 用指定的文件替代目前的crontab。 # 必须掌握：crontab -l [-u user] ## 列出用户目前的crontab. crontab -e [-u user] ## 编辑用户目前的crontab.# 通过crontab添加的计划任务都会存储在/var/spool/cron/目录里# 查看当前服务状态service crond status# 操作服务/sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置# 查看开机启动服务ntsysv # 退出时, 按tab切换# 加入开机自动启动chkconfig –level 35 crond on 配置说明 123456789101112131415161718# 基本格式 : * * * * * command 分 时 日 月 周 命令 # 每个小时的第几分钟执行该任务. 其它的类似第1列表示分钟1～59 每分钟用*或者 */1表示 第2列表示小时0～23（0表示0点） 7-9表示：8点到10点之间第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令# 记住几个特殊符号的含义:“*”代表取值范围内的数字,“/”代表”每”,“-”代表从某个数字到某个数字,“,”分开几个离散的数字 配置示例 123456789101112131415161718192021222324252627282930313233# * * * * * command # 分 时 日 月 周 命令 */1 * * * * date &gt;&gt; /root/date.txt上面的例子表示每分钟执行一次date命令可用 tail -f查看30 21 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示每晚的21:30重启apache45 4 1,10,22 * * /usr/local/etc/rc.d/httpd restart上面的例子表示每月1、10、22日的4 : 45重启apache10 1 * * 6,0 /usr/local/etc/rc.d/httpd restart 上面的例子表示每周六、周日的1 : 10重启apache0,30 18-23 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache0 23 * * 6 /usr/local/etc/rc.d/httpd restart上面的例子表示每星期六的11 : 00 pm重启apache* */1 * * * /usr/local/etc/rc.d/httpd restart上面的例子每一小时重启apache* 23-7/1 * * * /usr/local/etc/rc.d/httpd restart上面的例子晚上11点到早上7点之间，每隔一小时重启apache0 11 4 * mon-wed /usr/local/etc/rc.d/httpd restart上面的例子每月的4号与每周一到周三的11点重启apache0 4 1 jan * /usr/local/etc/rc.d/httpd restart 上面的例子一月一号的4点重启apache 更详细的见这里 8. Linux虚拟主机集群测试环境基本搭建1. 第一台虚拟主机的静态ip配置(针对于mac环境) 执行ifconfig命令, 如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667shixuanji@x:~|⇒ ifconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&lt;PERFORMNUD,DAD&gt;gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280stf0: flags=0&lt;&gt; mtu 1280EHC29: flags=0&lt;&gt; mtu 0EHC26: flags=0&lt;&gt; mtu 0XHC20: flags=0&lt;&gt; mtu 0en0: flags=8823&lt;UP,BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500 ether 60:03:08:a1:ac:ee nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect (&lt;unknown type&gt;) status: inactivep2p0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 2304 ether 02:03:08:a1:ac:ee media: autoselect status: inactiveawdl0: flags=8902&lt;BROADCAST,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484 ether 72:25:b2:c8:2a:03 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: inactiveen1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 32:00:1a:0d:12:00 media: autoselect &lt;full-duplex&gt; status: inactiveen2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 32:00:1a:0d:12:01 media: autoselect &lt;full-duplex&gt; status: inactivebridge0: flags=8822&lt;BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500 options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt; ether 32:00:1a:0d:12:00 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x2 member: en1 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 10 priority 0 path cost 0 member: en2 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 11 priority 0 path cost 0 media: &lt;unknown type&gt; status: inactiveutun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000 inet6 fe80::2ed8:c28:27b2:f5d2%utun0 prefixlen 64 scopeid 0xd nd6 options=201&lt;PERFORMNUD,DAD&gt;vmnet1: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:01 inet 172.16.63.1 netmask 0xffffff00 broadcast 172.16.63.255vmnet8: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:08 inet 192.168.170.1 netmask 0xffffff00 broadcast 192.168.170.255en4: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=3&lt;RXCSUM,TXCSUM&gt; ether 00:0e:c6:cc:ae:d7 inet6 fe80::1c60:7fe2:3947:4ec0%en4 prefixlen 64 secured scopeid 0x11 inet 192.168.63.148 netmask 0xffffff00 broadcast 192.168.63.255 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect (100baseTX &lt;full-duplex,flow-control&gt;) status: active 找到最后的vmnet8, 其中的 inet 就是虚拟主机的网段, 配置虚拟主机的静态ip的时候, 就配置此网段内的. 广播地址 broadcast也是虚拟主机NAT的广播地址, 配置时可以不填 123vmnet8: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:08 inet 192.168.170.1 netmask 0xffffff00 broadcast 192.168.170.255 修改虚拟机网卡配置vi /etc/sysconfig/network-scripts/ifcfg-eth, 做如下配置 123456789101112DEVICE=eth0HWADDR=00:0C:29:D6:C7:0ETYPE=EthernetUUID=bebc1b63-4f20-405a-860a-32d0d8211582ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=static # ip类型IPADDR=192.168.170.6 # ip地址, 与 vmnet8 在同一网段NETMASK=255.255.255.0 # 子网掩码GATEWAY=192.168.170.2 # 网关, 跟 ip在同一网段DNS1=192.168.170.2 # 与 ip 同一网段 DNS2=8.8.8.8 # google的 dns 重启网络服务 service network restart 2. 复制原本的虚拟主机 复制虚拟主机1到2 按照原虚拟主机的root用户名&amp;密码登录2 3. 修改新机网卡 修改网卡vi /etc/udev/rules.d/70-persistent-net.rules, 删除eth0所在的整个段落, 把下面的eth1改为eth0, 保存退出 修改网卡配置vi /etc/sysconfig/network-scripts/ifcfg-eth0, 如果有UUID, HARDDR, 删掉, IPADDR改为与原虚拟主机不同的地址, 但要在同一网段, BOOTPROTO改为static4. 修改新机hostname ​ 修改hostname, /etc/sysconfig/network, 把HOSTNAME改为要修改的名字 5. 免密登录 新机生成自己公钥 ssh-kepygen, 注意: 如果原本主机中已经生成, 此处在提示verwrite (y/n)?的时候要选择y, 才会重新生成覆盖 把新主机公钥发送给其它机器 ssh-copy-id root@xxx(其它主机ip), 此命令相当于 下面2条命令的效果 12cat id_rsa.pub &gt; authorized_keysscp -r authorized_keys root@192.168.123.202:/root/.ssh/ 其他主机也把公钥发给新主机, 此时就可以实现主机间的免密登录了. 6. 功能增强(可选) 可以在 每台机器中设置host别名, vi /etc/hosts, 加上xxx.xxx.xx.xxx cts1/2/3..., 这样在访问其他主机时, 可以直接用别名替代域名 如果是用的zsh的shell, 可以在所有主机的 ~.zshrc中, 添加alias login1=&#39;ssh root@cts1&#39; &gt;&gt; ~/.zshrc, 这样可以直接 用 login1登录到对应的主机. 9. 安装, 使用 zsh &amp; oh-my-zsh &amp;相关插件主骨架安装&amp;介绍 安装zsh套件 1yum install zsh -y 安装 oh-my-zsh套件 1sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" zsh 的一些基本配置操作, 常用插件安装见这里! 1234567891011121314151617181920# 查看oh-my-zsh 的主题ls ~/.oh-my-zsh/themes# 可以更改为random, 这样会随机显示, 很有乐趣, 直接输入zsh也会切换vi ~/.zshrcZSH_THEME="random"# 添加plugin, 按照对应方式安装plugins=(git ... ... )# 设置zsh为默认的shellchsh -s /bin/zsh# 添加alias 到 ~/.zshrcalias vi='vim'alias zshconfig='vi ~/.zshrc'alias vimconfig='vi ~/.vimrc'# 卸载 oh-my-zshuninstall_oh_my_zsh zsh zsh 的一些骚气操作 12345671. 兼容 bash, 这个就不用说了2. 输入某条命令, 比如 cat, 然后用上下键, 可以翻阅所有执行过的命令3. 各种补全, 输入任何命令, 按 2下 tab键, 下面会出现所有可能的补全, 可以 tab, 或 上下左右切换.4. 比如要杀掉进程java, 原来是需要 ps aux | grep java, 查进程的 PID，然后 kill PID; 现在只需要 kill java, 然后按下 tab, java会被替换为 对应的 PID, 点回车, kill !5. 目录浏览和跳转, 输入 d, 可以列出在这个回话中访问过的目录列表, 再输入列表前的序号, 即可直接跳转.6. 在当前目录下输入 .. 或 ... , 或者直接输入目录名, 都可以直接跳转, 甚至都不需要使用 cd命令了.7. 通配符搜索：ls -l */.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了. zsh主题介绍, zsh插件介绍 zsh常用插件安装安装 zsh-autosuggestions12345678910111213141516171819方式1: # 下载到本地git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions# 添加到.zshrc, 这样就不用每次source了添加 source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 到 .zshrc 尾部plugins=() 中添加上 zsh-autosuggestions, 用空格隔开即可======================方式2: 官方建议# 少了添加source到 ~/.zshrc这一步, 猜想是会按照默认的路径加载? # 1.Clone this repository into $ZSH_CUSTOM/plugins (by default ~/.oh-my-zsh/custom/plugins)git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions# 2.Add the plugin to the list of plugins for Oh My Zsh to load:plugins=(zsh-autosuggestions)# 3.Start a new terminal session. #####安装 autojump 1234567891011# 下载到本地git clone git://github.com/joelthelion/autojump.git# 执行安装脚本cd autojump./install.py# 安装完成在~/下面有.autojump目录, 在.zshrc中加一句[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh# 接下来可以愉悦的使用 j 了 安装 zsh-syntax-highlighting 12345678# 到 ~/.zshrc 目录, 克隆仓库git clone https://github.com/zsh-users/zsh-syntax-highlighting.git# source the script 到 ~/.zshrcecho "source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc# 在当前 shell生效source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
